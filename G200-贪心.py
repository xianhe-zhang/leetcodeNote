leetcode-455
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        ans = 0
        g.sort()
        s.sort()
        n = len(g)
        m = len(s)
        p0 = n - 1
        p1 = m - 1
        while p0 >= 0 and p1 >= 0:
            if s[p1] < g[p0]:
                p0 -= 1
            elif s[p1] >= g[p0]:
                ans += 1
                p0 -= 1
                p1 -= 1
        return ans
#ÁúãËøáÁ≠îÊ°àËá™Â∑±ÂÜôÁöÑÔºåÂÖàÊääÂ§ßÂùóÁöÑÈ•ºÂπ≤ÂàÜ‰∫´ÁªôËÉÉÂè£Â§ßÁöÑ„ÄÇ
#Ê®°ËåÉÁ≠îÊ°àÁöÑÊó∂Èó¥Á®çÂ•Ω
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        n, m = len(g), len(s)
        i = j = count = 0

        while i < n and j < m:
            while j < m and g[i] > s[j]:
                j += 1
            if j < m:
                count += 1
            i += 1
            j += 1
        
        return count
#ÂÆòËß£ÊÄùË∑Ø‰∏çÂ§™‰∏ÄÊ†∑Ôºå‰ªéÂ∞èÁöÑËµ∞ÔºåÂ∞èÁöÑÂÖàÂñÇÈ•±ÔºåÂñÇÈ•±ÂêéÂÜçÂñÇÂ§ßÁöÑ„ÄÇÂõ†‰∏∫È¢òÁõÆËÆæÁΩÆÔºåÊâÄ‰ª•‰∏§ÁßçÊÄùË∑ØÈÉΩÂèØ‰ª•ÔºåÂèØËÉΩËá™Â∑±ÁöÑÊÄùË∑Ø‰ºöÈÄ†Êàê‰∏Ä‰∏¢‰∏¢ËµÑÊ∫êÊµ™Ë¥π„ÄÇ

leetcode-435
#Ëá™Â∑±ÂÜôÁöÑ‚Äî‚ÄîÈîô‰∫ÜÔºåÂè™ÈÄÇÁî®‰∫é‰ªéÂ§¥ÂºÄÂßãÁöÑÊÉÖÂÜµÔºåÊ≤°ÊÉ≥Âà∞Â¶ÇÊûúÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†ÊòØ[1,100]ÊÄé‰πàÂäûÔºü
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        ans = 0 
        p0, p1 = 0, 1
        n = len(intervals)  #ÂåÖÂê´max_index
        while p1 < n and p0 < n:
            if intervals[p0][1] > intervals[p1][0]:
                p1 += 1
                ans += 1
            else:
                p0 += 1
                p1 += 1
        return ans

1- Ë¥™ÂøÉ
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        intervals.sort(key=lambda x: x[1]) #ÊåâÁÖßÂ∞æÂÖÉÁ¥†ÊéíÂàó
        #Ëøô‰∏™ÊåâÁÖßÂ∞æÂ∑¥ÊéíÂ∫èÊòØÊï¥‰∏™Ë¥™ÂøÉÁöÑÊ†∏ÂøÉ„ÄÇ
        n = len(intervals)                 #ÈïøÂ∫¶
        right = intervals[0][1]             
        ans = 1

        for i in range(1, n):
            if intervals[i][0] >= right:
                ans += 1    #ansÊòØÊúâÂá†‰∏™Âå∫Èó¥ÂèØ‰ª•ËøûÂú®‰∏ÄËµ∑
                right = intervals[i][1]
        
        return n - ans

leetcode-452
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0 

        points.sort()
        print(points)
        n = len(points)
        i = 0
        ans = j = 1 

        while True: #ËøôÈáåÂÜçÂÜô‰ªÄ‰πàÂÖ∂‰ªñÊåáÈíàÁöÑËæπÁïåÊù°‰ª∂Â∞±Ê≤°ÊúâÊÑè‰πâ‰∫ÜÔºåÂõ†‰∏∫‰Ω†ÁúãwhileÂæ™ÁéØÂ§ñÈù¢ÊòØÊ≤°ÊúâÁöÑreturnÁöÑÔºåÂè¶‰∏ÄÊñπÈù¢Ëøô‰πüÊòØ‰∏™hintËØ¥Êòé‰Ω†ÁöÑ‰ª£Á†ÅÂÜôÁöÑÂûÉÂúæ„ÄÇ

            if j == n :
                return ans

            while points[i][1] >= points[j][0] and j < n :
                if j == n - 1:
                    return ans
                else:
                    j += 1
            
            i = j
            j += 1
            ans += 1       
 
#‰∏äÈù¢ÊòØËá™Â∑±ÂÜôÁöÑÔºå‰ΩÜÊòØË∂ÖÊó∂...ÊàëÂÜôÁöÑÊÄùÊÉ≥ÊòØÔºåÂ¶ÇÊûúÊúÄÈù†Â∑¶ÁöÑÊ∞îÁêÉÁöÑÂè≥ËæπÁïåÈÉΩËÉΩÂõäÊã¨Âà∞ÂÖ∂‰ªñÊ∞îÁêÉÂ∑¶ËæπÁïåÁöÑËØùÔºå‰πüÂ∞±ÊòØËøô‰∏™Ê∞îÁêÉÁöÑÂè≥ËæπÁïåÁöÑÁÆ≠ËÉΩÂ§üÂ∞ÑÁ©øËøô‰∫õÊ∞îÁêÉÔºåÂàôÂèØ‰ª•ËÆ°ÁÆóÂá∫Êù•„ÄÇ
#Ëøô‰ª£Á†ÅÂÜôÁöÑÂ•ΩÂûÉÂúæÔºå‰∏ÄÁõ¥Âú®Êîπbug
"""
Âá†‰∏™Á¨îËÆ∞ÂèØ‰ª•ÂÅöÔºö
1. Âõ†‰∏∫ËøôÈáå‰∏çÊòØÂêåÂêëÂèåÊåáÈíàÔºåÂõ†Ê≠§whileË∑≥Âá∫Êù°‰ª∂ËÄÖÂà©Áî®Â§ßÂ∞è‰∏çÂ§™Â•ΩÁî®ÔºåÊàëÂÜôÁöÑË∑≥Âá∫Êù°‰ª∂Áõ¥Êé•‰∏∫return
2. ‰∏äÈù¢ÁÆóÊ≥ïËá¥ÂëΩÁöÑÈóÆÈ¢òÔºåÊ≤°ÊúâËÄÉËôëÂà∞‰∏ÄÁßçÊÉÖÂÜµÔºöÂ¶ÇÊûúÊâÄÊúâÁ¨¨‰∏Ä‰∏™ÂÄº‰∏∫[1Ôºå100]ÔºåÂÖ∂‰ªñÂÄºÈÉΩÊòØ1ÔΩû10ÔºåÂè™Êúâ‰∏Ä‰∏™‰∏∫11ÔΩû20ÔºåÈÇ£‰πàËøô‰∏™Êó∂ÂÄôÂè™ËÉΩÁî®2‰∏™ÊåáÈíà
3. Ê≤°ÊúâÊääÂÆûÈôÖÈóÆÈ¢òÊäΩË±°Âá∫Êù•ÂΩ¢ÊàêÊ®°Âûã„ÄÇ
"""
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        
        points.sort(key=lambda balloon: balloon[1])
        pos = points[0][1]
        ans = 1
        for balloon in points:
            if balloon[0] > pos:
                pos = balloon[1]
                ans += 1
        
        return ans
#Ë¥™ÂøÉÊÄùÊÉ≥ÊúâË∂£ÔºöÈ¶ñÂÖàÂèëÁé∞ÔºåÂ¶ÇÊûúÊÉ≥Ë¶ÅÂºìÁÆ≠Â∞ΩÈáèÂ∞ëÁöÑËØùÔºåÈÇ£‰πàÊàë‰ª¨‰∏ÄÂÆöÊòØË¶Å‰ΩøÂæóÂÆÉÁ©øË∂äÊõ¥Â§öÁöÑÊ∞îÁêÉ„ÄÇÂêåÊó∂Âõ†‰∏∫Ê∞îÁêÉÊòØÂõ∫ÂÆöÁöÑÔºåÊâÄ‰ª•Êàë‰ª¨Âè™Ë¶Å‰ªéÂ∞æÈÉ®Âú®ÊúÄÂ∑¶‰æßÁöÑÂºÄÂßãÁùÄÊâãÔºà‰∏ãÈù¢‰ºöËß£Èáä
#Â¶ÇÊûúÊúâÊ∞îÁêÉÁöÑÈ¶ñÈÉ®ËÉΩÂíåÊàë‰ª¨ÊâæÂà∞ÁöÑÊ∞îÁêÉÁöÑÊúÄÂè≥‰æßÈáçÂè†ÔºåÈÇ£‰πà‰∏Ä‰∏™ÂºìÁÆ≠ÂèØ‰ª•Ëß£ÂÜ≥Ëøô‰πàÂ§öÔºõÔºàËøôÂ∞±ÊòØË¥™ÂøÉÔºåÊØè‰∏ÄÂèëÂºìÁÆ≠ÔºåÊàë‰ª¨Â∞ΩÈáèÂ∏¶Ëµ∞Ê∞îÁêÉ
#ÊâÄ‰ª•ÂæÄÂè≥Ëµ∞ÔºåÂ¶ÇÊûúÊúâÊ∞îÁêÉxÊ≤°ÊúâËææÂà∞‰∏äÈù¢ÈÇ£‰∏™Ê∞îÁêÉÁöÑÂè≥‰æßÔºå‰πüÂ∞±ÊòØËØ¥ÂéüÊù•ÁöÑÈÇ£Ê†πÂºìÁÆ≠Êó†Ê≥ïÁ©øÁ†¥Ê∞îÁêÉxÔºåÈÇ£‰πàÂ∞±‰ª•Ëøô‰∏™Ê∞îÁêÉx‰∏∫Âü∫ÂáÜÔºåÊñ∞Â¢û‰∏ÄÊ†πÂºìÁÆ≠ÔºåÈáçÂ§ç‰∏äÈù¢ÁöÑÊìç‰ΩúÂç≥ÂèØÔºåÁõ¥Âà∞ÊúÄÂêé„ÄÇ
#ÊàëÁöÑÁ≠îÊ°àÈîôÁöÑ‰∏ªË¶ÅÂéüÂõ†ÊòØÂõ†‰∏∫ÊÄùË∑Ø‰∏çÂØπÔºÅ

leetcode-406
@ÊÄª‰ΩìÊÄùË∑ØÊòØÂÖàÊéíÂ∫èÂÜçÊèíÂÖ•
1-‰ªéÈ´òÂà∞‰Ωé
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key=lambda x: (-x[0], x[1]))
        n = len(people)
        ans = list()
        for person in people:
            ans[person[1]:person[1]] = [person] #Ëøô‰∏™ÂàáÁâáÊäÄÊúØ666ÔºåÂèØ‰ª•Â∞Ü[person]‰∏≠Âä†ÂÖ•Âà∞ansÔºåÂπ∂‰∏îËá™Âä®Êâ©Âº†ÈïøÂ∫¶„ÄÇ
        return ans

2- ‰ªé‰ΩéÂà∞È´ò
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key=lambda x: (x[0], -x[1]))    #‰∫åÁª¥Êï∞ÁªÑÂÖàÊåâÁÖßx[0]È°∫Â∫èÔºåÂÜçÊåâÁÖßx[1]ÁöÑÂÄíÂ∫èÊéíÈõ∑
        n = len(people)
        ans = [[] for _ in range(n)]
        for person in people:
            spaces = person[1] + 1  #ËøôÈáå+1Âõ†‰∏∫Ëá™Â∑±Êú¨Ë∫´ËøòÂç†ÁùÄ‰∏Ä‰ΩçÊï∞
            for i in range(n):
                if not ans[i]:      #Â¶ÇÊûúans[i]ÊúâÂÄºÔºåÈÇ£‰πàËøô‰∏™Âú∞Êñπ‰∏çËÉΩËÆ°Êï∞ÔºåÂõ†‰∏∫Êàë‰ª¨ÂÖàÊèíÁöÑÊòØÂ∞èÁöÑÂÄºÔºåÁõÆÂâçÊúâÂÄºÁöÑÊòØ‰∏çÂ∫îËØ•Ë¢´Á∫≥ÂÖ•ËÄÉËôëÁöÑ
                    spaces -= 1
                    if spaces == 0:  #Â¶ÇÊûúÁ≠â‰∫é0ÔºåÈÇ£‰πàÂ∞±ÊòØËøô‰∏™Êï∞ÁöÑ‰ΩçÁΩÆ
                        ans[i] = person
                        break
        return ans

leetcode-121
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        res = 0 
        low = float("inf")  #Áî®Êù•ÊúÄÂºÄÂßãËÆæÂÆöËæπÁïåÁî®
        for price in prices:
            low = min(low, price)   
            res = max(res, price - low)
        return res
#Ëøô‰∏ÄÈ¢òÁ¨¨‰∫åÊ¨°ÂÅö‰∫ÜÔºåÊ≤°ÂÅöÂá∫Êù•ÔºåÂéüÂõ†ÊòØÊ≤°ÊúâÁêÜËß£Ê†∏ÂøÉÊÄùÊÉ≥
#lowÊòØ‰∏∫‰∫ÜÊØèÊó•ÊúÄÂ∞èÂÄºÔºåresÁöÑÊòØÊâæÊúÄÂ∞èÂÄº‰∏éÂΩìÂâçpriceÁöÑÊúÄÂ§ß‰ª∑Â∑Æ„ÄÇ
@ÊàëËá™Â∑±‰ºöËÄÉËôëÊâÄÊúâÊÉÖÂÜµ-ËøôÊ†∑ÊÉ≥‰∏çÊòéÁôΩÔºåÂõ†‰∏∫Áª¥Â∫¶Â§™Â§öËÄå‰∏îÁõ∏‰∫í‰∫§Âèâ„ÄÇ
#Á≠îÊ°àÁöÑÊÄùË∑ØÔºöÂè™Âú®‰πéÊúÄÂ∞èÂÄºÔºåÂíåÂΩìÂâçprice‰∏éÊúÄÂ∞èÂÄºÁöÑ‰ª∑Â∑ÆÔºåËøô‰∏§‰∏™Ë¶ÅÁ¥†ÔºåÂ∞±ÂèØ‰ª•Â∫îÂØπÊâÄÊúâÊÉÖÂÜµÔºåcoolÔºÅ


leetcode-122
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        low = 0
        high = 1 
        n = len(prices)
        ans = 0

        while high < n:
            if prices[high] > prices[low]:
                ans += prices[high] - prices[low]
            high += 1
            low += 1

        return ans 
#ÊâãÊíï-ÁÆÄÂçï

leetcode-605
#Èò≤Âæ°ÂºèÁºñÁ®ãÔºåÂ¶Ç‰ΩïÂ§ÑÁêÜÊï∞Âàó‰∏§Á´ØÁöÑÊï∞ÊçÆÔºåÂèØ‰ª•Âú®È¶ñÂ∞æÂä†‰∏ä0
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed = [0] + flowerbed + [0]  #‰πüÂèØ‰ª•Áî®insert()
        i = 1
        ans = 0
        while i < len(flowerbed) - 1:
            if flowerbed[i] == 0 and flowerbed[i-1] == 0 and flowerbed[i+1] ==0:
                i += 2
                ans += 1
            else:
                i += 1
        return n <= ans
#Êó∂Èó¥ÂèØ‰ª•ÊòØÂø´ÁöÑÔºå‰ΩÜÊòØÁî±‰∫éÊ∑ªÂä†‰∫Ü‰∏§‰∏™ÂÖÉÁ¥†ÔºåÂõ†Ê≠§Á©∫Èó¥ÂèØËÉΩÁâ∫Áâ≤‰∏Ä‰∫õ
#ËøòÊúâ‰∏ÄÁßçËß£Ê≥ïÔºåÂ∞±ÊòØÊï∞ËøûÁª≠ÁöÑ0ÔºåÁÑ∂ÂêéÂà©Áî®Êï∞Â≠¶ÂΩíÁ∫≥Ê≥ïÔºåÂÜ≥ÂÆöÂèØ‰ª•ÁßçÂ§öÂ∞ëËä±

leetcode-392
#Áî®ÂèåÊåáÈíàÂæàÂÆπÊòìÂ∞±ÂÅöÂá∫Êù•È•ø‰∫Ü
#ËøôÈÅìÈ¢ò‰πüÂèØ‰ª•Áî®DPÁü©ÈòµÂéªÂÅöÔºå= ÊúÄÁü≠Ë∑ØÂæÑÈóÆÈ¢ò
@ËæπÁïåÈóÆÈ¢ò
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        dp = [[0] * len(s) for _ in range(len(t))] #dpÁöÑindexÂ∫îËØ•ÂíåiÂ•ëÂêàÔºåËøôÈáåÈúÄË¶ÅÂä†‰∏Ä
        for i in range(len(s)- 1):
            for j in range(len(t) - 1):
                if s[i] == t[j]:
                    dp[i + 1][j + 1] = dp[i][j] + 1 #ÊúÄÂºÄÂßãÂÄºÈÉΩ‰∏∫0ÔºåÂ¶ÇÊûúÂèëÁé∞Áõ∏ÂêåÂ≠óÊØçÔºåÂ∞±ËÆ°Êï∞
                else: 
                    dp[i][j + 1] = dp[i][j]
        return dp[-1][-1] == len(s)
#Ëøô‰∏™ÊÄùË∑ØÊòØÂØπÁöÑÔºå‰ΩÜÊòØlistÁöÑËæπÁïåÊúâÈóÆÈ¢òÔºåÂΩìÈÅçÂéÜÊúÄÂêé‰∏Ä‰∏™Â≠óÊØçÁöÑÊó∂ÂÄôÔºådpÂ∑≤ÁªèÊîæ‰∏ç‰∏ã‰∫Ü„ÄÇ‰∏ãÊñπ‰∏∫‰ºòÂåñÁâàÊú¨Ôºå‰∏ªË¶ÅÊîπÂä®Âú®index‰∏ä


@ÂàùÂßãÂåñÈóÆÈ¢ò
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]  #ËøôÈáåÂ¶ÇÊûúÈîô‰∫Ü‰ºöÂØºËá¥index assignment error
        for i in range(len(s)): #‰∏çÂáè‰∏ÄÊòØÂõ†‰∏∫Ë¶Å‰øùËØÅÈÅçÂéÜÊâÄÊúâ
            for j in range(len(t)):
                if s[i] == t[j]:
                    dp[i + 1][j + 1] = dp[i][j] + 1 #Âõ†‰∏∫indexÁöÑÂ≠òÂú®ÔºåÊâÄ‰ª•‰∏äÈù¢Áü©ÈòµÂä†1
                else: 
                    dp[i][j + 1] = dp[i][j]
        return dp[-1][-1] == len(s)
#Á¨ëÊ≠ªÊàë‰∫ÜÔºåÊàë‰∏∫‰ªÄ‰πàÁäØËøô‰πàÂõ∞ÈöæÁöÑÈîôËØØ
"""
ÈÅçÂéÜÈ°∫Â∫èÊòØ‰ª•i/s‰∏∫Âü∫ÂáÜÔºåÈÅçÂéÜjÁÑ∂ÂêéÂ∞Ü‰πãÂêéÁöÑÂÖ®ÈÉ®+1ÔºåÊØîÂ¶ÇÈÅáÂà∞‰∫ÜÂ≠óÊØçaÔºåÂ∞±ÁÆó‰πãÂêét‰∏≠ÂÜçÊúâÂ≠óÊØçaÔºåËøô‰∏™ÁÆóÊ≥ï‰πüÂèØ‰ª•‰øùËØÅdpÊï∞Â≠ó‰∏ÄÊ†∑Ôºå‰ªéËÄåËææÂà∞Ë∑≥Ëøá‰πãÂêéÁõ∏ÂêåÂ≠óÊØçÁöÑÂΩ±Âìç
Ê®°ÁâàÁ≠îÊ°à‰∏∫‰∏ãÔºåÊàëÂÜôÁöÑÈÄªËæëÊòØÊ≤°ÊúâÈÄªËæëÔºåÂõ†‰∏∫ÊòØÊåâÁÖßÁ≠îÊ°àÊîπÁöÑÔºÅüåüüåüüåüÈáçÁÇπ ËøôÊòØËøô‰∏ÄÈ¢òÁöÑtake-away
ÊàëËÄÉËôëÁöÑÊòØÂ∞ÜÁªìÊûúÂ≠òÂú®‰∏ã‰∏Äpart‰∏≠Ôºå‰ΩÜÊòØÊ≤°ÊúâËÄÉËôë‰πãÂêéÁöÑÊâÄÊúâÈÄªËæëÔºåÊâÄ‰ª•Âá∫Èîô„ÄÇ
"""
@Ê®°ÁâàÁ≠îÊ°à
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]
        for i in range(1, len(s)+1):
            for j in range(1, len(t)+1):
                if s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = dp[i][j-1]
        if dp[-1][-1] == len(s):
            return True
        return False

#TIPÔºöÈÅçÂéÜÊï∞ÁªÑÊó∂ÔºåÂà§Êñ≠ÂÖÉÁ¥†i‰∏éÂÖÉÁ¥†i+1Êó∂ÔºåÊúÄÂ•Ω‰∏çË¶Å‰øÆÊîπi+1 ËÄåÊòØ‰øÆÊîπiÔºå‰ª•ÂÖçÊé•‰∏ãÈáåÁöÑÂà§Êñ≠

#Á¶ÅÊ≠¢Èù¢ÂêëÊ°à‰æãÁºñÁ®ãÔºöÂú®Ê≤°ÊúâÂæàÂ•ΩÁöÑÂäûÊ≥ï‰∏ÄÊ¨°ÊÄßÂ§ÑÁêÜÈóÆÈ¢òÊó∂ÔºåÂç≥Êó†Ê≥ïÂ§ÑÁêÜËæπÈôÖ/Êù°‰ª∂Á≠âÔºåË¶ÅÈáçÊñ∞ÊÄùËÄÉÊÄùË∑ØÔºåÁúãÊúâÊ≤°ÊúâÊõ¥Â•ΩÁöÑÂ§ÑÁêÜÊñπÊ≥ïÂéªËß£ÂÜ≥ÈóÆÈ¢òÔºåÂê¶ÂàôÂ∞±‰ºöÂØºËá¥‚ÄúÈù¢ÂêëÊ°à‰æãÁºñÁ®ã‚ÄùÔºå‰πüÂ∞±ÊòØ‰ª£Á†ÅÂèàËá≠ÂèàÈïøÔºåËøô‰∏™Êó∂ÂÄôÂÄí‰∏çÂ¶ÇÁõ¥Êé•ÁúãÈ¢òËß£ÁàΩÂø´„ÄÇ

#index‰ΩøÁî®iÂíåi+1Êó∂‰ºöÂá∫Áé∞Â∞¥Â∞¨ÁöÑÊÉÖÊôØÔºåÂà§Êñ≠ÈÄªËæëÈáåÊØè‰∏ÄÊ¨°Âæ™ÁéØÂà§Êñ≠Â∫îËØ•Âè™ÈíàÂØπ‰∏Ä‰∏™Êñ∞ÁöÑÂÖÉÁ¥†Ôºå‰ΩÜÊòØÊ≠§Êó∂Êó†Ê≥ïËÄÉËôëÂà∞ÈòüÈ¶ñÔºåÂõ†‰∏∫ÂàöÂÖ•Âæ™ÁéØÁöÑÊó∂ÂÄôÔºåÊòØËøõÂÖ•‰∫Ü‰∏§‰∏™ÂÖÉÁ¥†ÔºåÂ¶ÇÊûúË¶ÅÂà†Èô§ÔºåÊó†Ê≥ïÂà§Êñ≠ÊòØÂà†Èô§iËøòÊòØÂà†Èô§i+1
#Ëøô‰∏™Êó∂ÂÄôÈúÄË¶ÅÂà§Êñ≠ÔºåËøôÁßçÂ∞¥Â∞¨ÁöÑÂú∫ÊôØË∑ünumsÁöÑsizeÊòØÂê¶ÊúâÂÖ≥ÔºåÂ¶ÇÊûú3‰∏™‰ª•ÂÜÖÊòØËøôÁßçÁâπ‰æãÔºåÈÇ£‰πàÈÄöËøáÈÅçÂéÜÁöÑÂºÄÂßãÊàñËÄÖÁâπÊÆäÂÄºÂ§ÑÁêÜÊéâÂ∞±Â•Ω„ÄÇ

#ËÉΩÁî®forÂ∞±‰∏çÁî®whileÔºåÁî®whileÊòØÂõ†‰∏∫ÂØπÊåáÈíàÂèØ‰ª•ËøõË°åÂ§ÑÁêÜÔºõ ÂèØ‰ª•Â§öÁî®iÂíåi-1ÔºåÂõ†‰∏∫ËøôÊ†∑Âè™Áî®ÈôêÂà∂ËåÉÂõ¥ÔºåÊØîËæÉÂÆπÊòìÁêÜËß£ÔºåÈíàÂØπËæπÁïåÂ§ÑÁêÜ‰πüÊØîËæÉÁÆÄÂçï„ÄÇ


leetcode-665
@ÈöæÁÇπ_Âú®‰∫éÊâÄÊúâÊÉÖÂÜµÊ≤°ÊúâÂÖÖÂàÜËÄÉËôëÂà∞Âπ∂‰∏î‰∏çÊ∏ÖÊ•öÂú®ÂêÑ‰∏™ÊÉÖÂÜµ‰∏ãÂØπÂ∫îÁöÑÁöÑÊìç‰ΩúÊñπÂºè
class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        p = 1 
        count = 0
        n = len(nums)
        while p < n:
            if nums[p - 1] > nums[p]:
                count += 1
                if p == 1 or nums[p] >= nums[p-2]:
                    nums[p - 1] = nums[p]
                else:
                    nums[p] = nums[p - 1]      
            p += 1
        return count <= 1
#ÈÄíÂ¢ûÂ∫èÂàó‰∏âÁßçÊÉÖÂÜµÔºö1.ÊúÄÂ§ßÂÄºÂú®ÈòüÈ¶ñ 2.Á™ÅÂá∫ÂÄºÂú®‰∏§ÂÖÉÁ¥†ÁöÑÁ¨¨‰∏Ä‰Ωç 3.Á™ÅÂá∫ÂÄºÂú®‰∏§ÂÖÉÁ¥†ÁöÑÁ¨¨‰∫å‰Ωç
#ÂÆèËßÇÊù•ÁúãÔºöÈô§‰∫ÜËæπÁïåÊÉÖÂÜµÔºåÂú®ÈòüÂàó‰∏≠ÈÅáÂà∞ÂºÇÂ∏∏ÊÉÖÂÜµ‰ºöÊúâ‰∏§ÁßçÊÉÖÂΩ¢Ôºå‰∏§ÁßçÊÉÖÂΩ¢ÁöÑÂ§ÑÁêÜÊñπÂºè‰∏çÂêå„ÄÇ

leetcode-53
@ÊúÄÂ§ßÂ≠êÂ∫èÂíå
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        temp = nums[0]                      #Ëøô‰∏™Êìç‰ΩúÂçÅÂàÜÈáçË¶ÅÔºåÂ¶ÇÊûú‰∏çÊòØÁõ¥Êé•Êìç‰ΩútempÔºåËÄåÊòØ‰ª•0ÂÖ•Âú∫ÔºåÈÇ£‰πàÂ¶ÇÊûúÊ≤°ÊúâÊª°Ë∂≥ÁöÑÊù°‰ª∂ÁöÑËØùÔºåËøîÂõûÁöÑÂÄº‰∏∫0ÔºåÂ∞ΩÁÆ°Á≠îÊ°à‰∏∫Ë¥üÊï∞
        ans = temp

        for i in range(1,len(nums)):
            temp = max(0, temp) + nums[i]    #temp = Â≠êÂ∫èÂàóÊúÄÂêé‰∏Ä‰Ωç‰∏∫nums[i]ÁöÑÊúÄÂ§ßÂÄº
            ans = max(ans, temp)             #ans  = 1.‰øùÂ≠òÊúÄÂ§ßÂÄº 2.ÊØîËæÉ‰∏çÂêåÂ≠êÂ∫èÂàóÁöÑÂíå
        return ans
#ËøôÁßç‰πüÁÆóÂàÜÊ≤ªÊÄùÊÉ≥
#‰∏ãÈù¢ÊòØÂ§ßÁ•ûDPÁöÑÁÆóÊ≥ïÔºåÁâõ„ÄÇ
class Solution(object):
    def maxSubArray(self, nums):
        for i in range(1, len(nums)):
            nums[i]= nums[i] + max(nums[i-1], 0) 
        return max(nums)

leetcode-763
#Ëøô‰∏ÄÈ¢òÈ¢òÁõÆÁêÜËß£Ëµ∑Êù•ÊúâÈöæÂ∫¶ÔºåË¥™ÂøÉÁÆóÊ≥ïÁöÑ‰ΩìÁé∞ÊòØ‰ªéÂ§¥ÈíàÂØπÂçï‰∏™Â≠óÊØçËøõË°åÂ§ÑÁêÜ„ÄÇ
class Solution:
    def partitionLabels(self, S: str) -> List[int]:
        dic = {s: index for index, s in enumerate(S)}   #dicÂÇ®Â≠òÂ≠óÊØç Âíå ÊúÄÂêé‰∏ÄÊ¨°Âá∫Áé∞ÁöÑindexÔºåÂÆûÁé∞by forÁöÑÈÅçÂéÜÂæ™ÁéØ #Ê≥®ÊÑèenuerateÁöÑÁî®Ê≥ï

        num = 0  #Áõ¥Êé•ËÆ°Êï∞
        result = []
        j = dic[S[0]]  #Á¨¨‰∏Ä‰∏™Â≠óÁ¨¶ÁöÑÊúÄÂêé‰ΩçÁΩÆ #S[0]ÊòØÂàóË°®


        for i in range(len(S)):  #ÈÄê‰∏™ÈÅçÂéÜ
            num += 1  #ÊâæÂà∞‰∏Ä‰∏™Â∞±Âä†1‰∏™ÈïøÂ∫¶
            if dic[S[i]] > j:  #ÊÄùË∑Ø‰∏ÄÊ†∑ÔºåÂ¶ÇÊûúÊúÄÂêé‰ΩçÁΩÆÊØîÂàöÊâçÁöÑÂ§ßÔºåÂ∞±Êõ¥Êñ∞ÊúÄÂêé‰ΩçÁΩÆ
                j = dic[S[i]]
            if i == j:  #ÊÄùË∑Ø‰∏ÄÊ†∑ÔºåÂΩ¢Âºè‰∏çÂêåÔºåËøôÈáåÂ∞±ÊòØÊâæÂà∞Ëøô‰∏ÄÊÆµÁöÑÁªìÊùü‰∫ÜÔºåÂ∞±ËØ¥ÊòéÂΩìÂâç‰ΩçÁΩÆÁöÑindexÂíåËøô‰∏™Â≠óÊØçÂú®Â≠óÂÖ∏ÈáåÁöÑÊúÄÂêé‰ΩçÁΩÆÂ∫îËØ•ÊòØÁõ∏ÂêåÁöÑ„ÄÇ -- Á≤æÂΩ©
                result.append(num)  # Âä†ÂÖ•result
                num = 0 # ÂΩí0  -- Á≤æÂΩ©
        return result 
