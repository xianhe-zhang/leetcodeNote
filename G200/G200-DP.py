"""
DPè§£é¢˜å››æ­¥èµ°ï¼š
    1.å®šä¹‰å­é—®é¢˜
    2.å†™å‡ºå­é—®é¢˜çš„é€’æ¨å…³ç³»
    3.ç¡®å®š DP æ•°ç»„çš„è®¡ç®—é¡ºåº
    4.ç©ºé—´ä¼˜åŒ–ï¼ˆå¯é€‰
"""

from _typeshed import IdentityFunction
from typing import ItemsView, List


leetcode-70 çˆ¬æ¥¼æ¢¯
#è‡ªå·±å†™çš„ï¼Œçœç•¥äº†å‡ ä¸ªå¾ªç¯
class Solution:
    def climbStairs(self, n: int) -> int:
        if n < 3:
            return n 
        i = 2
        dp = [0] * n  #ğŸŒŸè¿™é‡Œå¿…é¡»æœ‰0ï¼Œå¦åˆ™bugæˆå±±
        dp[0] = 1
        dp[1] = 2
        while i < n:
            dp[i] = dp[i-2] + dp[i-1]
        return dp[n-1]  
#é¢˜è§£-åˆ©ç”¨äº†dp[0]æ›´å®¹æ˜“ç†è§£é‹
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [] * (n+1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2, n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]
#ç©ºé—´ä¼˜åŒ–
class Solution:
    def climbStairs(self, n: int) -> int:
        pre, cur = 1, 1
        for i in range(n-1):
            pre, cur = cur, pre + cur
        return cur



leetcode-198 æ‰“å®¶åŠ«èˆ
def rob(self, nums: List[int]) -> int:
    prev = 0
    curr = 0
    
    # æ¯æ¬¡å¾ªç¯ï¼Œè®¡ç®—â€œå·åˆ°å½“å‰æˆ¿å­ä¸ºæ­¢çš„æœ€å¤§é‡‘é¢â€
    for i in nums:
        # å¾ªç¯å¼€å§‹æ—¶ï¼Œcurr è¡¨ç¤º dp[k-1]ï¼Œprev è¡¨ç¤º dp[k-2]
        # dp[k] = max{ dp[k-1], dp[k-2] + i }   #è¡¨ç¤ºå·ç¬¬kä¸ªæˆ¿å­æ—¶çš„æœ€å¤§å€¼
        prev, curr = curr, max(curr, prev + i)
        # å¾ªç¯ç»“æŸæ—¶ï¼Œcurr è¡¨ç¤º dp[k]ï¼Œprev è¡¨ç¤º dp[k-1]

    return curr
#åˆ©ç”¨dp[]æ˜¯æ²¡æœ‰è¿›è¡Œç©ºé—´ä¼˜åŒ–çš„è§£æ³•ï¼›æœ€åç»“æœåªä¸k-1 å’Œ k-2æœ‰å…³ï¼Œå› æ­¤ç”¨ä¸¤ä¸ªå˜é‡è¡¨ç¤ºå°±å¯ä»¥äº†ã€‚

----------------  @å°šæœªä¼˜åŒ–é¢˜è§£
def rob(self, nums: List[int]) -> int:
    if len(nums) == 0:
        return 0
    N = len(nums)
    dp = [0] * (N+1)
    dp[0] = 0
    dp[1] = nums[0]
    for k in range(2, N+1):
        dp[k] = max(dp[k-1], nums[k-1] + dp[k-2])
    return dp[N]
----------------  @è‡ªå·±å†™çš„
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        elif len(nums) == 1:
            return nums[0]
        n = len(nums)
        dp = [[] for _ in range(n)]
        dp[0] = nums[0]
        dp[1] = max(nums[0],nums[1])    #é˜Ÿé¦–çš„å¤„ç†ååˆ†ç»†èŠ‚ã€‚å·§å¦™åœ°å›é¿äº†è¾¹ç•Œçš„é™·é˜±
        i = 2
        while i < n:
            dp[i] = max(dp[i-2]+nums[i], dp[i-1])
            i += 1
        return dp[n-1]
#å¯ä»¥çœ‹å‡ºæ¥è‡ªå·±å†™çš„ä»£ç é•¿ï¼ŒåŸå› æ˜¯å› ä¸ºè‡ªå·±æ²¡æœ‰æ€è€ƒå®Œæ•´ï¼Œ[k]çš„æœ€å¤§å€¼éœ€è¦k-1å’Œk-2ï¼Œé‚£ä¹ˆå°±è¦è€ƒè™‘é˜Ÿé¦–çš„å…ƒç´ åº”è¯¥æ€ä¹ˆå¤„ç†ã€‚ä¼˜åŒ–çš„æ–¹æ³•å€ŸåŠ©äº†dp[0]=0


leetcode-213 æ‰“å®¶åŠ«èˆII
#ç¯çŠ¶æˆ¿å±‹ï¼Œé‚£ä¹ˆèƒ½æŠŠç¯åˆ‡æˆä¸¤ä¸ªåˆ—
class Solution:
    def rob(self, nums: List[int]) -> int:
        def iRob(nums):
            pre , cur = 0, 0
            for num in nums:
                cur, pre = max(cur, num + pre), cur #åˆ«å¿˜å‚¨å­˜çš„ä¸¤ä¸ªå€¼åŒæ—¶å˜æ¢
            return cur
        return max(iRob(nums[1:]), iRob(nums[:-1])) if len(nums) != 1 else nums[0] 


leetcode-64
class Solution:
    def minPathSum(self, grid: [[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == j == 0: continue
                elif i == 0:  grid[i][j] = grid[i][j - 1] + grid[i][j]
                elif j == 0:  grid[i][j] = grid[i - 1][j] + grid[i][j]
                else: grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j]
        return grid[-1][-1]
#è¿˜æ˜¯ç›¸å½“äºåˆ—å‡ºäº†æ‰€æœ‰çš„å¯èƒ½æ€§ï¼Œå› ä¸ºè¾¹ç•Œå®åœ¨æ— æ³•æœ€å°å€¼ï¼Œä½†æ˜¯ä¸­é—´çš„å€¼å¯ä»¥é€‰æ‹©æœ€å°å€¼ã€‚

leetcode-62
#è‡ªå·±å†™çš„æ²¡æœ‰ä¼˜åŒ–
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        if n == 0 or m == 0:
            return 1
        steps = [[0] * m for _ in range(n)] #æé”™äº†ï¼Œmé‚£é‡Œåº”è¯¥ä¸ºnï¼Œåº”è¯¥æ˜¯colã€‚å¥½åœ¨è¿™ä¸€é¢˜ä¸å½±å“ç»“æœã€‚
        print(steps[0])
        for i in range(n):
            for j in range(m):
                if i == 0 or j == 0: steps[i][j] = 1
                else: steps[i][j] = steps[i][j-1] + steps[i-1][j]
        return steps[-1][-1]
@ä¼˜åŒ–çš„é¢˜è§£
#è¿™ä¸€é¢˜ä¼˜åŒ–åï¼Œæ¯ä¸€æ¬¡åˆ¤æ–­ä¹Ÿæ˜¯åªç”¨å‚¨å­˜å‰ä¸¤ä¸ªå€¼ï¼›è¿™ä¸ªè§£æ³•è€ƒè™‘äº†æ•°å­¦å› ç´ ï¼Œæ— è®ºèµ°ä¸Šèµ°ä¸‹æ¯ä¸ªå•å…ƒæ ¼éƒ½æœ‰æ„ä¹‰ï¼Œæ¯ä¸ªå•å…ƒæ ¼éƒ½åº”è¯¥åŠ èµ·æ¥ã€‚
#è¿™ä¸€é¢˜åªç”¨äº†ä¸€åˆ—çš„ç©ºé—´ï¼Œç„¶åæ¯ä¸€æ¬¡éå†çš„æ—¶å€™è¿›è¡Œä¼˜åŒ–ï¼Œå¤ªæé™äº†...
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        cur = [1] * n
        for i in range(1, m):   #ğŸŒŸè¿™é‡Œçš„1æ˜¯å…³é”®ï¼Œæ„å‘³ç€ä¸è€ƒè™‘ä¸¤ä¸ªè¾¹ç•Œã€‚
            for j in range(1, n):
                cur[j] += cur[j-1]
        return cur[-1]

leetcode-303(easy)
@å®˜æ–¹é¢˜è§£
#åˆ©ç”¨å‰ç¼€å’Œçš„æ€æƒ³
class NumArray:

    def __init__(self, nums: List[int]):
        self.sums = [0]  #ç”¨selfå£°æ˜å¯ä»¥å˜ä¸ºå…¨å±€å˜é‡ï¼Œå…¶ä»–æ–¹æ³•ä¹Ÿå¯ä»¥è°ƒç”¨äº†ã€‚
        _sums = self.sums

        for num in nums:
            _sums.append(_sums[-1] + num)

    def sumRange(self, i: int, j: int) -> int:
        _sums = self.sums
        return _sums[j + 1] - _sums[i]
# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(left,right)

#è¿™ä¸€é¢˜å°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æœ‰numsï¼Œé‚£ä¹ˆå¦‚ä½•ç”¨è¿™ä¸¤ä¸ªæ–¹æ³•é…åˆï¼Œä»è€Œæ›´å¿«åœ°å®ç°æˆ‘ä»¬çš„sumRangeåŠŸèƒ½ï¼›æœ¬é¢˜çš„ç®—æ³•æ˜¯åœ¨åˆå§‹åŒ–æ•°æ®çš„æ—¶å€™åˆ©ç”¨å‰ç¼€å’Œçš„æŠ€å·§ï¼Œç„¶åsumrangeç›´æ¥æ‰§è¡Œè¿ç®—ä¾¿å¯ã€‚
#å¤æ‚åº¦å‡ä¸ºO(n)


leetcode-413
#DPè§£æ³•
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        tmp_cnt = 0
        cnt = 0
        n = len(nums)
        for i in range(n-2):
            if nums[i+1] - nums[i] == nums[i+2] - nums[i+1]:
                tmp_cnt += 1
                cnt += tmp_cnt #è¿™ä¸ªåœ°æ–¹ä¸è¦æ”¾é”™ï¼Œå¦åˆ™ä¼šå¤šå†™å‡ è¡Œä»£ç ï¼Œæ”¾åœ¨è¿™é‡Œæ²¡æœ‰å½±å“ã€‚
            else:
                tmp_cnt = 0
        return cnt
#å¤æ‚åº¦ä¸ºnï¼Œç©ºé—´ä¸º1
@ä¸é€‚åº”çš„æ„Ÿè§‰å°±æ˜¯åœ¨æé«˜çš„æ—¶å€™

#åŒæŒ‡é’ˆè§£æ³•-å¤æ‚åº¦ç¨é«˜
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums)
        self.res = 0
        self.helper(nums, n-1)
        return self.res
    
    def helper(self, nums, end): #helperåˆ©ç”¨äº†é€’å½’ï¼Œ
        if end < 2:
            return 0
        cnt = 0
        if nums[end-1] - nums[end] == nums[end-2] - nums[end-1]:
            cnt = 1 + self.helper(nums, end-1)  #è¿™ä¸€è¡Œéå¸¸éš¾ç†è§£ï¼Œæµ‹ä¾‹[1,2,3,4]ï¼›end = 4çš„æ—¶å€™å…¶å® cnt = 1 + 1; end = 3 çš„æ—¶å€™ cnt = 1
            """
            å¦‚ä½•ç†è§£å‘¢ï¼Ÿå› ä¸ºcntåœ¨æ¯ä¸€ä¸ªå¾ªç¯ä¸­éƒ½ä¼šåˆå§‹åŒ–ï¼Œé‚£ä¹ˆself.helperè¿™é‡Œç©¶ç«Ÿç­‰äºå‡ å…¶å®æ˜¯ä»åº•å±‚ç§¯ç´¯èµ·æ¥çš„ã€‚æ¯”å¦‚432,4321ï¼Œé‚£ä¹ˆåœ¨end = 4çš„æ—¶å€™ï¼Œcnt =2
            è¿™æ ·å› ä¸ºæ¯ä¸€å±‚éƒ½ä¼šç´¯ç§¯ï¼Œéƒ½è¿›å…¥resï¼Œè¿™æ ·å°±ç›¸å½“äºendä¸ºå„ä¸ªå…ƒç´ çš„æ‰€æœ‰å­é€’å¢åˆ—éƒ½è¿›å…¥äº†ï¼Œä¸ç®¡é•¿åº¦å¤šå°‘ã€‚éå¸¸å·§å¦™
            """
            self.res += cnt
        else:
            self.helper(nums, end-1)
        return cnt
#æ—¶é—´å¤æ‚åº¦ä¸ºn2ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºNï¼ˆè°ƒç”¨æ ˆæœ€å¤§æ·±åº¦ä¸ºNï¼‰

#æ»‘åŠ¨çª—å£
#æ€è·¯ï¼šä»é˜Ÿé¦–å¼€å§‹ï¼Œå¦‚æœæ»¡è¶³ï¼Œåˆ™å³æŒ‡é’ˆå³ç§»ï¼›å¦‚æœä¸æ»¡è¶³ï¼Œå·¦æŒ‡é’ˆä¸æŒ‡é’ˆæ¥è½¨ã€‚
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        if not nums or len(nums) < 3:
            return 0
        res = 0
        L = 2
        predif = nums[1] - nums[0]
        n = len(nums)
        for i in range(1, n-1):
            dif = nums[i+1] - nums[i]
            if dif == predif:
                L += 1              #Læ˜¯ç”¨æ¥åˆ¤æ–­è¯¥ç­‰å·®æ•°åˆ—å¤šé•¿ï¼Œç„¶ååˆ©ç”¨æ•°å­¦çš„æ–¹æ³•æ±‚å‡ºæœ‰å¤šå°‘ç§ç»„åˆ
            else:
                res += (L-1) * (L-2) // 2 #L=3çš„è¯ï¼Œåªæœ‰ä¸€ç§ç»„åˆï¼›
                L = 2
                predif = dif
        res += (L-1) * (L-2) // 2   #æœ€åå¦‚æœæœ‰çš„è¯è¿˜è¦å­˜å…¥
        return res


leetcode-343 æ•´æ•°æ‹†åˆ†
#è¿™ä¸€é¢˜ä¸»è¦æ¶‰åŠæ•°å­¦å½’çº³
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[2] = 1
        for i in range(3, n + 1):
            # å‡è®¾å¯¹æ­£æ•´æ•° i æ‹†åˆ†å‡ºçš„ç¬¬ä¸€ä¸ªæ­£æ•´æ•°æ˜¯ jï¼ˆ1 <= j < iï¼‰ï¼Œåˆ™æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹æ¡ˆï¼š
            # 1) å°† i æ‹†åˆ†æˆ j å’Œ iâˆ’j çš„å’Œï¼Œä¸” iâˆ’j ä¸å†æ‹†åˆ†æˆå¤šä¸ªæ­£æ•´æ•°ï¼Œæ­¤æ—¶çš„ä¹˜ç§¯æ˜¯ j * (i-j)
            # 2) å°† i æ‹†åˆ†æˆ j å’Œ iâˆ’j çš„å’Œï¼Œä¸” iâˆ’j ç»§ç»­æ‹†åˆ†æˆå¤šä¸ªæ­£æ•´æ•°ï¼Œæ­¤æ—¶çš„ä¹˜ç§¯æ˜¯ j * dp[i-j]
            for j in range(1, i - 1):
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
        return dp[n]
#å¤æ‚åº¦n2
#è‡ªå·±æ‰¾åˆ°çµæ„Ÿäº†ï¼Œä½†æ˜¯å°±æ”¾è¿‡å»äº†ã€‚

@æ•°å­¦å½’çº³
class Solution:
    def integerBreak(self, n: int) -> int:
        if n <= 3: return n - 1
        a, b = n // 3, n % 3
        if b == 0: return int(math.pow(3, a))
        if b == 1: return int(math.pow(3, a - 1) * 4)
        return int(math.pow(3, a) * 2)


leetcode-279 å®Œå…¨å¹³æ–¹æ•°
1-DP
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [0] * (n+1)            
        for i in range(1, n+1):
            j = 1
            dp[i] = i               #æŒ‰ç…§æœ€å¤šçš„æ•°å­—ï¼Œæ¯ä¸€ä¸ªå¹³æ–¹æ•°éƒ½æ‹†æˆ1è¡¨ç¤º
            while j * j <= i:
                dp[i] = min(dp[i-j*j] + 1, dp[i])         #æŒ‰ç…§itemçœ‹æ¯ä¸€ä¸ªèƒŒåŒ…ï¼Œè¿™é‡Œdp[â„¹ï¸]è¡¨ç¤ºæ•°å­—iæ—¶ï¼Œèƒ½æ‹†æˆå¹³æ–¹æ•°æœ€å°çš„ç»„åˆã€‚
                j += 1
        return dp[n]

2-å››å¹³æ–¹å’Œå®šç†-ä»»æ„ä¸€ä¸ªæ­£æ•´æ•°éƒ½å¯ä»¥è¢«è¡¨ç¤ºä¸ºè‡³å¤šå››ä¸ªæ­£æ•´æ•°çš„å¹³æ–¹å’Œ
#åªç”¨åˆ¤å®š1ï¼Œ2ï¼Œ4å°±è¡Œï¼›1å’Œ4æƒ…å†µç‰¹æ®Šï¼Œç›´æ¥åˆ¤æ–­ï¼›2å¾ªç¯åˆ¤æ–­ï¼›3ç›´æ¥ç”¨æ’é™¤æ³•
3-å®Œå…¨èƒŒåŒ…
class Solution:
    import math
    def numSquares(self, n: int) -> int:
        #dp[i] è¡¨ç¤ºå’Œä¸º i çš„ nums ç»„åˆä¸­å®Œå…¨å¹³æ–¹æ•°æœ€å°‘æœ‰ dp[i] ä¸ªã€‚
        dp = [float('inf')]*(n+1)
        dp[0] = 0
        #å¯ä¾›é€‰åˆ™çš„numsåˆ—è¡¨ [1,4,9,...,sqrt(n)]  ä»ä¸­ä»»æ„æŒ‘é€‰æ•°å­—ç»„æˆå’Œä¸ºn
        #å®Œå…¨èƒŒåŒ…
        for i in range(1, int(math.sqrt(n))+1):
            for j in range(n+1):
                if(j>=i*i):
                    dp[j] = min(dp[j], dp[j-i*i]+1)
        return dp[n]

"""
3-å®Œå…¨èƒŒåŒ…DPï¼ˆå­¦ä¹ ä¸€ä¸‹  
nums = [i*i for i in range(1, int(n**0.5)+1)]               #æŠŠç¬¦åˆç›®æ ‡çš„æ‰€æœ‰å¹³æ–¹æ•°æ”¾è¿›numsèƒŒåŒ…é‡Œ
f = [0] + [float('inf')]*n                                  #f[i]æ˜¯æœ€å°‘éœ€è¦å¤šå°‘ä¸ªå¹³æ–¹æ•°åº”è¯¥ã€‚ åˆ¶é€ å‡º13ä½æ•°å­—listï¼Œåˆšå¥½å¯¹åº”index        
for num in nums:                                            
    for j in range(num, n+1):                               
        f[j] = min(f[j], f[j-num]+1)                        #è¿™ä¸ªè½¬åŒ–æœ‰æ„æ€ï¼Œè¦ä¹ˆæ˜¯f[j]ä¸åŠ¨ï¼Œè¦ä¹ˆå°±æ˜¯
return f[-1]

4-è´ªå¿ƒ
ps = set([i * i for i in range(1, int(n**0.5)+1)])      #**æ˜¯è¡¨ç¤ºå¹‚çš„æ„æ€
def divisible(n, count):
    if count == 1: return n in ps
    for p in ps:
        if divisible(n-p, count-1):
            return True
    return False

for count in range(1, n+1):
    if divisible(n, count):
        return count
"""
------------------------------------èƒŒåŒ…é—®é¢˜ä¸“è¾‘----------------------------------------------------
"""
é¦–å…ˆæ˜¯èƒŒåŒ…åˆ†ç±»çš„æ¨¡æ¿ï¼š
1ã€0/1èƒŒåŒ…ï¼šå¤–å¾ªç¯nums,å†…å¾ªç¯target,targetå€’åºä¸”target>=nums[i];
2ã€å®Œå…¨èƒŒåŒ…ï¼šå¤–å¾ªç¯nums,å†…å¾ªç¯target,targetæ­£åºä¸”target>=nums[i];
3ã€ç»„åˆèƒŒåŒ…ï¼šå¤–å¾ªç¯target,å†…å¾ªç¯nums,targetæ­£åºä¸”target>=nums[i];
4ã€åˆ†ç»„èƒŒåŒ…ï¼šè¿™ä¸ªæ¯”è¾ƒç‰¹æ®Šï¼Œéœ€è¦ä¸‰é‡å¾ªç¯ï¼šå¤–å¾ªç¯èƒŒåŒ…bags,å†…éƒ¨ä¸¤å±‚å¾ªç¯æ ¹æ®é¢˜ç›®çš„è¦æ±‚è½¬åŒ–ä¸º1,2,3ä¸‰ç§èƒŒåŒ…ç±»å‹çš„æ¨¡æ¿

ç„¶åæ˜¯é—®é¢˜åˆ†ç±»çš„æ¨¡æ¿ï¼š
1ã€æœ€å€¼é—®é¢˜: dp[i] = max/min(dp[i], dp[i-nums]+1)æˆ–dp[i] = max/min(dp[i], dp[i-num]+nums);
2ã€å­˜åœ¨é—®é¢˜(bool)ï¼šdp[i]=dp[i]||dp[i-num];
3ã€ç»„åˆé—®é¢˜ï¼šdp[i]+=dp[i-num];

è‡ªå·±çš„ç¬”è®°ï¼š
    1. æ­£åº/å€’åºä¸»è¦æ˜¯å› ä¸ºè¿›è¡Œäº†ç©ºé—´ä¼˜åŒ–ï¼Œå®Œå…¨ç»„åˆèƒŒåŒ…é—®é¢˜ï¼ˆé‡å¤åˆ©ç”¨ä¸€ä¸ªå…ƒç´ ï¼‰å°±æ˜¯éœ€è¦åˆ©ç”¨åˆ°å·²ç»æ›´æ–°çš„æ•°æ®ï¼Œå› æ­¤æ­£åºæ²¡å…³ç³»ï¼›å€’åºä¸èƒ½ç”¨åˆ°æ›´æ–°åˆ°å½“å‰è¡Œçš„æ•°æ®ï¼Œè¦åˆ©ç”¨ä¸Šä¸€è¡Œçš„æ•°æ®ï¼Œå› æ­¤éœ€è¦å€’åºã€‚
    2. äºŒç»´æ¯”ä¸€ç»´å®¹æ˜“ç†è§£ã€‚
    3. è®°ä½çŠ¶æ€è½¬ç§»æ–¹ç¨‹å‰çš„æ¡ä»¶åˆ¤æ–­æœ‰æ—¶å€™æœ‰è¾¹ç•Œé—®é¢˜ã€‚
    4. çŠ¶æ€è½¬ç§»çš„ç¡®è®¤æœ‰å‡ ä¸ªexï¼š1. æœ€åä¸€ä½æ•°å¾€å‰é¢çš„ç»„åˆåŠ ä¸Šå» 2. æ˜¯å¦é€‰æ‹©å½“å‰å…ƒç´   3.å‰é¢çœ‹åé¢çš„å…ƒç´ ï¼ˆéš¾ç†è§£...è‡ªå·±èƒ¡è¯´çš„
"""
1-é›¶é’±å…‘æ¢
#é›¶é’±å…‘æ¢ï¼šç»™å®šamount,æ±‚ç”¨ä»»æ„æ•°é‡ä¸åŒé¢å€¼çš„é›¶é’±æ¢åˆ°amountæ‰€ç”¨çš„æœ€å°‘æ•°é‡
#å®Œå…¨èƒŒåŒ…æœ€å€¼é—®é¢˜ï¼šå¤–å¾ªç¯coins,å†…å¾ªç¯amountæ­£åº,åº”ç”¨çŠ¶æ€æ–¹ç¨‹1
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        #dp[i] è¡¨ç¤ºæ¢åˆ°é¢å€¼iæ‰€éœ€è¦çš„æœ€å°æ•°é‡
        dp = [float('inf')]*(amount+1)
        dp[0] = 0 #dp[i]:æ¢åˆ°é¢å€¼iæ‰€ç”¨çš„æœ€å°æ•°é‡

        for i in range(len(coins)):
            for j in range(coins[i], amount+1): #æœ€å°é¢å€¼ä»coins[i]å¼€å§‹è®¡ç®—
                dp[j] = min(dp[j], dp[j-coins[i]]+1)
        
        if dp[amount]!=float('inf'):
            return dp[amount]
        else:
            return -1
2-åˆ†å‰²ç­‰å’Œå­é›†
#åˆ†å‰²ç­‰å’Œå­é›†ï¼šåˆ¤æ–­æ˜¯å¦èƒ½å°†ä¸€ä¸ªæ•°ç»„åˆ†å‰²ä¸ºä¸¤ä¸ªå­é›†,å…¶å’Œç›¸ç­‰
#0-1èƒŒåŒ…å­˜åœ¨æ€§é—®é¢˜ï¼šæ˜¯å¦å­˜åœ¨ä¸€ä¸ªå­é›†,å…¶å’Œä¸ºtarget=sum/2,å¤–å¾ªç¯nums,å†…å¾ªç¯targetå€’åº,åº”ç”¨çŠ¶æ€æ–¹ç¨‹2
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        s_sum = sum(nums)
        if  s_sum%2==1:
            return False
        target =    s_sum//2
        dp = [False]*(target+1) #dp[i]æ˜¯å¦å­˜åœ¨å­é›†å’Œä¸ºi
        dp[0] = True #åˆå§‹åŒ–ï¼štarget=0ä¸éœ€è¦é€‰æ‹©ä»»ä½•å…ƒç´ ï¼Œæ‰€ä»¥æ˜¯å¯ä»¥å®ç°çš„
        for i in range(len(nums)):
            for j in range(target, nums[i]-1, -1): #nums[i]-1 æœ€å°å–åˆ°num[i]
                dp[j] = dp[j] or dp[j-nums[i]]
        return dp[target]
    
3-ç›®æ ‡å’Œ
#ç›®æ ‡å’Œï¼šç»™æ•°ç»„é‡Œçš„æ¯ä¸ªæ•°å­—æ·»åŠ æ­£è´Ÿå·å¾—åˆ°target
#æ•°ç»„å’Œsum,ç›®æ ‡å’Œs, æ­£æ•°å’Œx,è´Ÿæ•°å’Œy,åˆ™x+y=sum,x-y=s,é‚£ä¹ˆx=(s+sum)/2=target
#0-1èƒŒåŒ…ä¸è€ƒè™‘å…ƒç´ é¡ºåºçš„ç»„åˆé—®é¢˜:é€‰numsé‡Œçš„æ•°å¾—åˆ°targetçš„ç§æ•°,å¤–å¾ªç¯nums,å†…å¾ªç¯targetå€’åº,åº”ç”¨çŠ¶æ€æ–¹ç¨‹3
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        num_sum =sum(nums)
        if (num_sum<target or (num_sum+target)%2!=0):
            return 0 
        target = (num_sum+target)//2
        dp = [0]*(target+1)  #dp[i]:å’Œä¸ºiçš„ä¸åŒè¡¨è¾¾å¼çš„æ•°ç›®
        dp[0] = 1
        for i in range(len(nums)):
            for j in range(target, nums[i]-1, -1):
                dp[j] += dp[j-nums[i]]
        return dp[target]

4-å®Œå…¨å¹³æ–¹æ•°
#å®Œå…¨å¹³æ–¹æ•°ï¼šå¯¹äºä¸€ä¸ªæ­£æ•´æ•°n,æ‰¾å‡ºè‹¥å¹²ä¸ªå®Œå…¨å¹³æ–¹æ•°ä½¿å…¶å’Œä¸ºn,è¿”å›å®Œå…¨å¹³æ–¹æ•°æœ€å°‘æ•°é‡
#å®Œå…¨èƒŒåŒ…çš„æœ€å€¼é—®é¢˜ï¼šå®Œå…¨å¹³æ–¹æ•°æœ€å°ä¸º1,æœ€å¤§ä¸ºsqrt(n),æ•…é¢˜ç›®è½¬æ¢ä¸ºåœ¨nums=[1,2.....sqrt(n)]ä¸­é€‰ä»»æ„æ•°å¹³æ–¹å’Œä¸ºtarget=n
#å¤–å¾ªç¯nums,å†…å¾ªç¯targetæ­£åº,åº”ç”¨è½¬ç§»æ–¹ç¨‹1
class Solution:
    import math
    def numSquares(self, n: int) -> int:
        #dp[i] è¡¨ç¤ºå’Œä¸º i çš„ nums ç»„åˆä¸­å®Œå…¨å¹³æ–¹æ•°æœ€å°‘æœ‰ dp[i] ä¸ªã€‚
        dp = [float('inf')]*(n+1)
        dp[0] = 0
        #å¯ä¾›é€‰åˆ™çš„numsåˆ—è¡¨ [1,4,9,...,sqrt(n)]  ä»ä¸­ä»»æ„æŒ‘é€‰æ•°å­—ç»„æˆå’Œä¸ºn
        #å®Œå…¨èƒŒåŒ…
        for i in range(1, int(math.sqrt(n))+1):
            for j in range(n+1):
                if(j>=i*i):
                    dp[j] = min(dp[j], dp[j-i*i]+1)
        return dp[n]

5-ç»„åˆæ€»å’ŒV
#åœ¨numsä¸­ä»»é€‰ä¸€äº›æ•°,å’Œä¸ºtarget
#è€ƒè™‘é¡ºåºçš„ç»„åˆé—®é¢˜ï¼šå¤–å¾ªç¯target,å†…å¾ªç¯nums,åº”ç”¨çŠ¶æ€æ–¹ç¨‹3
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        #dp[i]è¡¨ç¤ºæ€»å’Œä¸ºiçš„å…ƒç´ ç»„åˆçš„ä¸ªæ•°
        dp = [0]*(target+1)
        dp[0] = 1
        for i in range(target+1):
            for j in range(len(nums)):
                if i>=nums[j]:
                    dp[i] += dp[i-nums[j]]
        return dp[target]
    
6-é›¶é’±å…‘æ¢II
#é›¶é’±å…‘æ¢2ï¼šä»»é€‰ç¡¬å¸å‡‘æˆæŒ‡å®šé‡‘é¢,æ±‚ç»„åˆæ€»æ•°
#å®Œå…¨èƒŒåŒ…ä¸è€ƒè™‘é¡ºåºçš„ç»„åˆé—®é¢˜ï¼šå¤–å¾ªç¯coins,å†…å¾ªç¯targetæ­£åº,åº”ç”¨è½¬ç§»æ–¹ç¨‹3
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        #dp[i]è¡¨ç¤ºå‡‘æˆæ€»é‡‘é¢ä¸ºiçš„ç¡¬å¸ç»„åˆæ•°
        dp = [0]*(amount+1)
        dp[0] = 1
        for i in range(len(coins)):
            for j in range(amount+1):
                if j>=coins[i]:
                    dp[j]+= dp[j-coins[i]]
        return dp[amount]

7-æœ€åä¸€å—çŸ³å¤´çš„é‡é‡
"""
è¿™é“é¢˜çœ‹å‡ºæ˜¯èƒŒåŒ…é—®é¢˜æ¯”è¾ƒæœ‰éš¾åº¦
æœ€åä¸€å—çŸ³å¤´çš„é‡é‡ï¼šä»ä¸€å †çŸ³å¤´ä¸­,æ¯æ¬¡æ‹¿ä¸¤å—é‡é‡åˆ†åˆ«ä¸ºx,yçš„çŸ³å¤´,è‹¥x=y,åˆ™ä¸¤å—çŸ³å¤´å‡ç²‰ç¢;è‹¥x<y,ä¸¤å—çŸ³å¤´å˜ä¸ºä¸€å—é‡é‡ä¸ºy-xçš„çŸ³å¤´æ±‚æœ€åå‰©ä¸‹çŸ³å¤´çš„æœ€å°é‡é‡(è‹¥æ²¡æœ‰å‰©ä¸‹è¿”å›0)
é—®é¢˜è½¬åŒ–ä¸ºï¼šæŠŠä¸€å †çŸ³å¤´åˆ†æˆä¸¤å †,æ±‚ä¸¤å †çŸ³å¤´é‡é‡å·®æœ€å°å€¼
è¿›ä¸€æ­¥åˆ†æï¼šè¦è®©å·®å€¼å°,ä¸¤å †çŸ³å¤´çš„é‡é‡éƒ½è¦æ¥è¿‘sum/2;æˆ‘ä»¬å‡è®¾ä¸¤å †åˆ†åˆ«ä¸ºA,B,A<sum/2,B>sum/2,è‹¥Aæ›´æ¥è¿‘sum/2,Bä¹Ÿç›¸åº”æ›´æ¥è¿‘sum/2
è¿›ä¸€æ­¥è½¬åŒ–ï¼šå°†ä¸€å †stoneæ”¾è¿›æœ€å¤§å®¹é‡ä¸ºsum/2çš„èƒŒåŒ…,æ±‚æ”¾è¿›å»çš„çŸ³å¤´çš„æœ€å¤§é‡é‡MaxWeight,æœ€ç»ˆç­”æ¡ˆå³ä¸ºsum-2*MaxWeight;ã€
0/1èƒŒåŒ…æœ€å€¼é—®é¢˜ï¼šå¤–å¾ªç¯stones,å†…å¾ªç¯target=sum/2å€’å™,åº”ç”¨è½¬ç§»æ–¹ç¨‹1
"""
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        target = sum(stones)//2
        #dp[i]å®¹é‡ä¸ºiçš„èƒŒåŒ…æ”¾è¿›å»çš„çŸ³å¤´çš„æœ€å¤§é‡é‡
        dp = [0]*(target+1)
        #01èƒŒåŒ… æœ€å€¼é—®é¢˜
        for i in range(len(stones)):
            for j in range(target, stones[i]-1, -1):
                    dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])
        return sum(stones)-2*dp[target]

8-æ·éª°å­çš„Nç§æ–¹æ³•
#æŠ•æ·éª°å­çš„æ–¹æ³•æ•°ï¼šdä¸ªéª°å­,æ¯ä¸ªæœ‰fä¸ªé¢(ç‚¹æ•°ä¸º1,2,...f),æ±‚éª°å­ç‚¹æ•°å’Œä¸ºtargetçš„æ–¹æ³•
#åˆ†ç»„0/1èƒŒåŒ…çš„ç»„åˆé—®é¢˜ï¼šdp[i][j]è¡¨ç¤ºæŠ•æ·iä¸ªéª°å­ç‚¹æ•°å’Œä¸ºjçš„æ–¹æ³•æ•°;ä¸‰å±‚å¾ªç¯ï¼šæœ€å¤–å±‚ä¸ºèƒŒåŒ…d,ç„¶åå…ˆéå†targetåéå†ç‚¹æ•°f
#åº”ç”¨äºŒç»´æ‹“å±•çš„è½¬ç§»æ–¹ç¨‹3ï¼šdp[i][j]+=dp[i-1][j-f]
class Solution:
    def numRollsToTarget(self, d: int, f: int, target: int) -> int:
        #dp[i][j] æŠ•iä¸ªéª°å­ï¼Œç‚¹æ•°ä¹‹å’Œä¸ºjçš„æ–¹æ³•æ•°
        dp = [[0]*(target+1) for i in range(d+1)]
        dp[0][0] = 1
        for i in range(1, d+1):
            for j in range(1, target+1):
                for k in range(1, f+1):
                    if j>=k: #ç‚¹æ•°ä¹‹å’Œå¤§äºå½“å‰é¢ä¸Šçš„ç‚¹æ•°
                        dp[i][j] += dp[i-1][j-k]
        return dp[d][target]

------------------------------------èƒŒåŒ…é—®é¢˜ç»“æŸ--------------------------------------------

leetcode91-è§£ç æ–¹æ³•
@è‡ªå·±å†™çš„
class Solution:
    def numDecodings(self, s: str) -> int:
        num_list = []
        for i in list(s):   #å°†listä¸­çš„å­—ç¬¦ä¸²è½¬åŒ–ä¸ºlistä¸­çš„int
            num_list.append(int(i))
        print(num_list)
        dp = [0] * (len(num_list)t+1)
        dp[0] = 0
        for i in num_list:  
            for j in range(len(dp)):
                if i == 0:
                    dp[i] = dp[i-1]
                else: return 0
#âŒå†™åˆ°è¿™é‡Œå¡ä½äº†ï¼Œå› ä¸ºæˆ‘çš„åˆ¤æ–­æ–¹æ³•åŒæ—¶éœ€è¦å½“å‰éå†çš„iå’Œä¸Šä¸€è½®éå†çš„iï¼Œå› æ­¤è¯¥æ–¹æ³•è¡Œä¸é€šã€‚

@é¢˜è§£
#æ€è·¯ï¼šä¸éš¾å‘ç°ï¼Œè¾¹é™…æœ€æƒ¨çš„æ²¡æœ‰ç»„åˆï¼Œæ¯”å¦‚å…¨æ˜¯9. å¦‚æœæœ‰ç»„åˆï¼Œè¿™ä¸€é¢˜å½“ä¸­å°±æ˜¯ç‰¹æ®Šæƒ…å†µï¼Œç‰¹æ®Šå¤„ç†ä¾¿å¯ï¼›é€šè¿‡é¢˜æ„ä¸éš¾å‘ç°ï¼Œé¢˜ç›®å½“å‰ç­”æ¡ˆä¸å·²éå†çš„å…ƒç´ æœ‰å…³ï¼Œå› æ­¤æå‡ºæ¦‚å¿µï¼šæ»šåŠ¨æ•°ç»„
#åŒæ—¶å­¦åˆ°äº†å­—ç¬¦ä¸²çš„ç®€æ˜“è½¬åŒ–æ–¹å¼
#è¿™ä¸€é¢˜æ²¡æœ‰æƒ³åˆ°çš„æ˜¯ï¼šç»„åˆæˆåŠŸä¸ä»…ä»…æ˜¯+1ï¼Œè€Œæ˜¯ç¿»ä¸€å€ï¼Œæ„å‘³ç€ä¹‹å‰çš„ç»„åˆæ•°é‡ï¼Œéƒ½å¯ä»¥æœ‰ä¸€ä¸ªå…¨æ–°çš„å˜åŒ–
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        s = ' ' + s 
        f = [0] * (n + 1)
        f[0] = 1
        for i in range(1,n + 1):
            a = ord(s[i]) - ord('0')
            b = ( ord(s[i - 1]) - ord('0') ) * 10 + ord(s[i]) - ord('0') #åˆ—è¡¨ä¸­çš„å­—ç¬¦æ•°å­—å¤„ç†æ–¹å¼ ord(s[i]) - ord('0') 
            if 1 <= a <= 9:
                f[i] = f[i - 1]
            if 10 <= b <= 26:
#è¿™ä¸ªå¾ˆå¦™ï¼Œä¸ºä»€ä¹ˆä¸æ˜¯f[i] = f[i-2]*2? #å¦‚æœæ˜¯*2ï¼Œæ„å‘³ç€åä¸¤ä½æ•°çš„ä¸¤ç§å˜åŒ–å åŠ åˆ°ä¹‹å‰çš„æ•°ä¸Šï¼Œé‚£ä¹ˆè¿™æ ·éå†çš„åŸºæœ¬å…ƒç´ æ˜¯ä¸¤ä½æ•°è€Œéä¸€ä½æ•°ï¼Œå› æ­¤æ€è·¯ä¸é€šã€‚
#é™¤æ­¤ä¹‹å¤–ï¼Œ*2å¿½ç•¥äº†ä¸€ç§æƒ…å†µï¼Œå°±æ˜¯i-1è·Ÿi-2ä¸æ˜¯åˆ†å‰²å¼€çš„ï¼Œä»–ä»¬ä¹Ÿæœ‰å¯èƒ½ç»„æˆä¸€ä½2ä½æ•°ï¼Œå› æ­¤ä¸æˆç«‹ã€‚
#f[i] + f[i-2] = f[i-1] +f[i-2] å¦‚æœä¸¤è€…ç›¸åŒï¼Œå°±æ˜¯è·Ÿ*2ä¸€è‡´ï¼›å¦‚æœä¸åŒï¼Œf[i-1]å°±æ˜¯ä¸¤ä¸ªå…ƒç´ åˆ†å‰²ï¼Œè€Œf[i-2]å°±æ˜¯ä¸¤ä¸ªå…ƒç´ ä¸€èµ·å åŠ åˆ°åˆ—è¡¨ä¸­å»ã€‚
                f[i] += f[i - 2]                            
        return f[n]

@ç©ºé—´ä¼˜åŒ–
#æ ¹æ®æ€è·¯å‘ç°ï¼Œä¸éœ€è¦n+1ä¸ªfï¼Œå› ä¸ºæ¯æ¬¡å¾ªç¯åªè·Ÿä¸Šä¸¤ä¸ªæ•°å­—æœ‰å…³ç³»ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªé•¿åº¦ä¸º3çš„æ»šåŠ¨æ•°ç»„æ¥æ›¿ä»£ã€‚
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        s = ' ' + s
        f = [0] * 3
        f[0] = 1
        for i in range(1,n + 1):
            f[i % 3] = 0        #å®šä½åˆ°ä½™æ•°
            a = ord(s[i]) - ord('0')
            b = ( ord(s[i - 1]) - ord('0') ) * 10 + ord(s[i]) - ord('0')
            if 1 <= a <= 9:     
                f[i % 3] = f[(i - 1) % 3]       #è¿™é‡Œé‡å¤åˆ©ç”¨äº†é•¿åº¦ä¸º3çš„ç©ºé—´ï¼Œé¡ºåºä¸€è‡´ï¼Œä½†æ˜¯ä½ç½®ä¸ä¸€å®šä¸€è‡´ç½¢äº†ã€‚
            if 10 <= b <= 26:
                f[i % 3] += f[(i - 2) % 3]
        return f[n % 3]
#ä¼˜åŒ–çš„æ ¸å¿ƒå°±æ˜¯: i % 3, (i-1) % 3, (i-2) % 3ï¼Œé¡ºåºä¸€è‡´å°±è¡Œï¼Œä½ç½®ä¸ç”¨ç®¡ã€‚
#DPå¯¹äºæˆ‘çš„æ ¸å¿ƒéš¾ç‚¹å°±æ˜¯ï¼š1.å°†é—®é¢˜æŠ½è±¡æˆæˆ‘ç†Ÿæ‚‰çš„è§£é¢˜æ¨¡å‹ã€‚2.å‘ç°çŠ¶æ€è½¬ç§»çš„å­˜åœ¨ 3.çŠ¶æ€è½¬ç§»æ–¹ç¨‹çš„ä¹¦å†™

leetcode-300 æœ€é•¿é€’å¢å­åºåˆ—
#è§£æ³•ä¸€ï¼šæš´åŠ› Big O = n^2ã€‚ä½†æš´åŠ›çš„è¯å°±æ²¡æ„æ€äº†;
    #åŒæ—¶æš´åŠ›è§£æ³•æœ‰ä¸¤ç§æ€è·¯ï¼šdp[i]ä¸ºé¦–ä½çš„æœ€å¤§é€’å¢å­åºåˆ—ï¼Œdp[i]ä¸ºæœ«ä½çš„æœ€å¤§é€’å¢å­åºåˆ—ï¼›
    #å‰è€…ä¸ºéå†å¾ªç¯ï¼Œåè€…ä¸ºDPï¼Œè™½ç„¶éƒ½æ˜¯æš´åŠ›è§£æ³•ï¼Œä½†æ˜¯åè€…ä¼šå¿«ä¸€äº›ï¼Œå› ä¸ºåˆ©ç”¨äº†iä¸i-1ä¹‹é—´çš„çŠ¶æ€è½¬ç§»
# Dynamic programming.
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums: return 0
        dp = [1] * len(nums)
        for i in range(len(nums)):
            for j in range(i):
                if nums[j] < nums[i]: # å¦‚æœè¦æ±‚éä¸¥æ ¼é€’å¢ï¼Œå°†æ­¤è¡Œ '<' æ”¹ä¸º '<=' å³å¯ã€‚ #è¿™ä¸€æ­¥ä¹Ÿå¯ä»¥éå†iä¹‹å‰çš„æ‰€æœ‰å…ƒç´ ï¼Œé€‰æ‹©æœ€å¤§çš„å­åºåˆ—åŠ å…¥
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
#Take-Away: è¿™é¢˜çš„çŠ¶æ€è½¬åŒ–æ€è·¯æ²¡æœ‰ææ‡‚ï¼šdp[i]æ˜¯ä»¥iå…ƒç´ ä¸ºç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„å…ƒç´ æ•°ï¼Œåœ¨éå†çš„æ—¶å€™å­é—®é¢˜æ˜¯å¦‚æœnums[i]> nums[j]ï¼Œé‚£ä¹ˆå°±å¯ä»¥è®²nums[i]æ·»åŠ åˆ°ä»¥nums[j]ç»“å°¾çš„æœ€å¤§é€’å¢å­åºåˆ—é˜Ÿå°¾
#ä»¥å½“å‰
#è§£æ³•äºŒï¼šBig O = n * logn
    #æœ‰äº†å¯¹è§£æ³•ä¸€çš„ç†è§£ï¼Œé‚£ä¹ˆå¦‚æœå°†äºŒåˆ†æŸ¥æ‰¾åµŒå…¥åˆ°è§£é¢˜æ€è·¯ä¸­ï¼Œå¤æ‚åº¦å°±ä¼šå˜ä¸ºLognï¼›
# Dynamic programming + Dichotomy.
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        size = len(nums)
        # ç‰¹åˆ¤
        if size < 2:
            return size

        # ä¸ºäº†é˜²æ­¢ååºé€»è¾‘å‘ç”Ÿæ•°ç»„ç´¢å¼•è¶Šç•Œï¼Œå…ˆæŠŠç¬¬ 1 ä¸ªæ•°æ”¾è¿›å»
        tail = [nums[0]] #æ³¨æ„tailæ˜¯ä¸ªå­åºåˆ—æ•°ç»„ï¼Œtail[i]è®°å½•çš„æ˜¯é•¿åº¦ä¸º(i+1)çš„é€’å¢å­åºåˆ—çš„æœ€å°æœ«å°¾å€¼
        """
        Q: ä¸ºä»€ä¹ˆè¦æœ«å°¾æœ€å°  Aï¼šå› ä¸ºè¿™æ ·å¯ä»¥é¿å…æ¼æ‰æŸäº›åºåˆ—
        Qï¼šè´ªå¿ƒçš„ç‚¹åœ¨å“ªï¼Ÿ Aï¼šé‡åˆ°æœ€å°çš„ï¼Œè¿›è¡Œæœ«å°¾æ›¿æ¢
        Qï¼šå¦‚ä½•ç¡®å®šéå†äº†æ‰€æœ‰ï¼ŸåŸºç¡€é€»è¾‘æ˜¯ï¼Ÿ Aï¼š
        Qï¼šäºŒåˆ†ä¼˜åŒ–åœ¨å“ªï¼Ÿ Aï¼šåœ¨ä»¥numä¸ºåŸºç¡€çš„æƒ…å†µä¸‹ï¼Œå¯»æ‰¾å®ƒåœ¨tailä¸­çš„ä½ç½®
        """
        for i in range(1, size):
            # ã€é€»è¾‘ 1ã€‘æ¯” tail æ•°ç»„å®é™…æœ‰æ•ˆçš„æœ«å°¾çš„é‚£ä¸ªå…ƒç´ è¿˜å¤§
            # å…ˆå°è¯•æ˜¯å¦å¯ä»¥æ¥åœ¨æœ«å°¾
            if nums[i] > tail[-1]:
                tail.append(nums[i])
                continue

            # ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ³•ï¼Œåœ¨æœ‰åºæ•°ç»„ tail ä¸­
            # æ‰¾åˆ°ç¬¬ 1 ä¸ªå¤§äºç­‰äº nums[i] çš„å…ƒç´ ï¼Œå°è¯•è®©é‚£ä¸ªå…ƒç´ æ›´å°
            left = 0
            right = len(tail) - 1
            while left < right:
                # é€‰å·¦ä¸­ä½æ•°ä¸æ˜¯å¶ç„¶ï¼Œè€Œæ˜¯æœ‰åŸå› çš„ï¼ŒåŸå› è¯·è§ LeetCode ç¬¬ 35 é¢˜é¢˜è§£
                # mid = left + (right - left) // 2
                mid = (left + right) >> 1
                if tail[mid] < nums[i]:
                    # ä¸­ä½æ•°è‚¯å®šä¸æ˜¯è¦æ‰¾çš„æ•°ï¼ŒæŠŠå®ƒå†™åœ¨åˆ†æ”¯çš„å‰é¢
                    left = mid + 1
                else:
                    right = mid
            # èµ°åˆ°è¿™é‡Œæ˜¯å› ä¸ºã€é€»è¾‘ 1ã€‘çš„åé¢ï¼Œå› æ­¤ä¸€å®šèƒ½æ‰¾åˆ°ç¬¬ 1 ä¸ªå¤§äºç­‰äº nums[i] çš„å…ƒç´ ï¼Œå› æ­¤æ— éœ€å†å•ç‹¬åˆ¤æ–­
            tail[left] = nums[i]
        return len(tail)
#ä½†æ˜¯tail = [i] è™½ç„¶æ¯ä¸ªiå€¼è™½ç„¶å‚¨è—çš„æ˜¯é•¿åº¦ä¸º(i+1)çš„æœ€å°æœ«å°¾å€¼ï¼Œä½†æ˜¯åœ¨ä¸åŸæœ¬tailä¸­çš„å€¼æ›¿æ¢çš„æ—¶å€™è¿˜æ˜¯ä¼šé€ æˆä¸€äº›æµªè´¹ï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€è¦æ›¿æ¢æœ€åä¸€ä½å°±å¯ä»¥ï¼Œå‰é¢çš„éƒ½æ˜¯é”¦ä¸Šæ·»èŠ±ã€‚
#âŒä¸Šå¥ååŠéƒ¨åˆ†é”™äº†ï¼åªåˆ¤æ–­æœ€åä¸€ä½æ²¡æœ‰åŠæ³•ç¡®è®¤è¿™ä¸ªæ•°æ˜¯å¦åº”è¯¥æ”¾åœ¨æœ€åä¸€ä½è¿˜æ˜¯æ”¾åœ¨å…¶ä»–ä½ã€‚

    
#â€œå›æº¯â€çš„æ€æƒ³ååˆ†é‡è¦ï¼Œå³i å’Œ i-1ï¼Œè€Œéi å’Œ i+1ï¼›å› ä¸ºè®¡ç®—æœºåªçŸ¥é“ä½ éå†è¿‡çš„å…ƒç´ ï¼Œä¸æ¸…æ¥šå®ƒè¿˜æ²¡éå†è¿‡çš„å…ƒç´ ã€‚


leetcode-646 æœ€é•¿æ•°å¯¹é“¾
#è‡ªå·±çš„æ€è·¯æ˜¯å…ˆæ’åºï¼Œç„¶åå»çœ‹é¦–ä½ï¼Œä»è€Œå†³å®šæœ‰å‡ ä¸ªå¯ä»¥æ»¡è¶³ï¼› ä½†è¿™ä¸ªå†™æ³•ç®—æ˜¯è´ªå¿ƒï¼Œä¸æ˜¯dp
1- DP
class Solution(object): #Time Limit Exceeded
    def findLongestChain(self, pairs):
        pairs.sort()
        dp = [1] * len(pairs)

        for j in range(len(pairs)):
            for i in range(j):
                if pairs[i][1] < pairs[j][0]:
                    dp[j] = max(dp[j], dp[i] + 1)

        return max(dp)

#for x, y in sorted(pairs, key = operator.itemgetter(1)) 
#for x, y in sorted(pairs, key = lambda x: x[1]) // lambda x, y: x[1], -x[0]

2-greed #è‡ªå·±ä¸å®Œå–„çš„æ€è·¯
class Solution:
    def findLongestChain(self, pairs):
        pairs.sort(key = lambda x: x[1]) #æŒ‰ç…§æœ«å°¾æ’åºï¼Œè·Ÿä¸²æ°”çƒä¸€æ ·ã€‚
        cur, res = float('-inf'), 0
        for x, y in pairs:
            if x > cur:
                cur = y
                res += 1
        return res

leetcode-376 æ‘†åŠ¨åºåˆ—
#âŒæˆ‘çš„æ€è·¯ï¼šæ¯æ¬¡å­˜åœ¨ä¸Šå‡/ä¸‹é™çš„åˆ¤æ–­ï¼Œå› æ­¤éœ€è¦flagå˜é‡å»å¸®åŠ©å¾ªç¯åˆ¤æ–­ï¼Œä½†æ˜¯flagçš„å¼€å§‹æˆç«‹é€‚ç”¨äºéé‡å¤é›†åˆï¼Œå› æ­¤æˆ‘çš„ç®—æ³•å¿…å®šä¼šæœ‰ä¸€äº›ç‰¹æ®Šæƒ…å†µé¡¾è™‘ä¸åˆ°ï¼›
# å½“ç„¶ä¹Ÿå¯ä»¥å¤šåŠ æœºåˆ¶å»æ§åˆ¶è¿™ç§ç‰¹æ®Šæƒ…å†µï¼Œä½†å¤æ‚åº¦å°±ç¨å¾®é«˜äº†ã€‚å› æ­¤æˆ‘çš„æ€è·¯ä¸å¤ªåˆé€‚ï¼Œä½†æ˜¯å¤§æ–¹å‘æ˜¯å¯¹çš„ï¼âœ…
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        size = len(nums)
        if size < 2 : return size
        if size == 2 and nums[0] == nums[1]: return 1
        if nums[0] > nums[1]: 

@é¢˜è§£
#å¤§ä½¬æ€è·¯æœç„¶ç‰›ï¼æ–°å»ºäº†ä¸¤ä¸ªå˜é‡ï¼Œå¦™å¤„ï¼š1. é¢˜ç›®å…³äºansæ˜¯æœ‰ä¸¤å¥—åˆ¤æ–­é€»è¾‘çš„ï¼Œä¸¤ä¸ªå˜é‡å„è´Ÿè´£ä¸€ä¸ªï¼› 2. ä¸¤ä¸ªå˜é‡è™½ç„¶å¾ªç¯éƒ½æ“ä½œï¼Œç¢°åˆ°åˆé€‚çš„æƒ…å†µä¸‹ï¼Œæ“ä½œæ‰æœ‰æ•ˆï¼ğŸŒŸè¿™ä¸¤ç‚¹å¾ˆé‡è¦ï¼Œè®°ä¸‹ï¼
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        if not nums: return 0
        up, down = 1, 1
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                up = down + 1
            if nums[i] < nums[i-1]:
                down = up + 1
        return max(up, down)
        #return 0 if len(nums) == 0 else max(up, down)  #ç”¨è¿™ä¸ªæ›´å¿«ï¼
#Big O = n

leetcode-1143 æœ€é•¿å…¬å…±å­åºåˆ—
#è‡ªå·±çš„æ€è·¯æ˜¯å¯¹çš„ã€‚ä½†æ²¡æœ‰è€ƒè™‘åˆ°æ‰€æœ‰æƒ…å†µï¼Œè€Œä¸”ä¸çŸ¥é“å¦‚ä½•å†™å‡ºæ¥ã€‚
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n, m = len(text1) ,len(text2)
        dp = [[0] * (m+1) for _ in range(n+1)]
        for i in range(1, n+1):
            for j in range(1, m+1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1 #ä¸ºä»€ä¹ˆè¦ç”¨[i-1][j-1]? é¦–å…ˆ[j-1]å®¹æ˜“ç†è§£ï¼Œå³ä»ä¸Šä¸€ä¸ªéå†çš„å…ƒç´ ç»§æ‰¿è¿‡æ¥ï¼›[i-1]å¯ä»¥é¿å…æ‰ä¸Šä¸ªjå…ƒç´ å·²ç»ä½¿ç”¨è¿‡çš„åœºæ™¯ï¼ˆæ¯”å¦‚ä¸¤ä¸ªeå¯¹åº”1ä¸ªeï¼‰ï¼Œå› æ­¤å¦‚æœæˆ‘ä»¬å‘ç°æœ‰è¯¥åˆ—æœ‰æ»¡è¶³çš„æƒ…å†µåº”è¯¥ä»ä¸Šä¸€è¡Œä¸Šä¸€åˆ—çš„è§’åº¦å‡ºå‘è€ƒè™‘ï¼ˆå›æº¯ï¼‰

                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) #é¦–å…ˆæ˜ç™½ä¸€ç‚¹ï¼Œä¸æ»¡è¶³çš„æ—¶å€™æ˜¯å¦‚ä½•ç»§æ‰¿çš„ï¼Ÿ äºŒç»´æ•°ç»„æ€»ç»“å¦‚ä¸‹â¬‡ï¸
        "[i][j]åªèƒ½é€šè¿‡[i-1][j]/[i][j-1]ä¸­æ¥ï¼Œä¸ºä»€ä¹ˆè¦maxå‘¢ï¼Ÿ1.å¦‚æœè¯¥è¡Œå‰é¢æœ‰å¯¹åº”ä¸Šçš„è€Œæœ¬å…ƒç´ æ²¡æœ‰å¯¹åº”ï¼Œé‚£ä¹ˆæœ¬å…ƒç´ ç»§æ‰¿ä»[i-1]å¤„ç»§æ‰¿ 2.å¦‚æœå¤„ç†çš„å…ƒç´ åˆšå¥½æ˜¯è¿™ä¸ªï¼Œé‚£ä¹ˆä»ä¸Šä¸€è¡Œè¯¥è¡Œå…ƒç´ ç»§æ‰¿"
        #æ¯”è¾ƒéš¾ç†è§£ï¼Œå¸Œæœ›å¤šåšé¢˜æ”¹å–„ã€‚
        return dp[-1][-1]
# bugå†™ä½œå°èƒ½æ‰‹ï¼ŒdpäºŒç»´æ•°ç»„çš„listå¼„æ··äº†ã€‚ä¸‹é¢çš„iå’Œjå†™é”™ä½ç½®äº†ï¼›åˆ›å»ºäºŒç»´æ•°ç»„çš„æ—¶å€™ï¼Œ[0]*n æ˜¯ä¸€ä¸ªåº•å±‚æ•°ç»„ï¼Œè€Œfor _ in range(m)æ˜¯æœ€é•¿å±‚æ•°ç»„ï¼Œä¹Ÿå°±æ˜¯dp[m][n]
# å­åºåˆ—çš„ç»†èŠ‚å¤„ç†é—®é¢˜ï¼Œå·²ç»åœ¨æ–‡ä¸­äº†ã€‚

@æ»šåŠ¨æ•°ç»„ä¼˜åŒ–
#ä¸ºä»€ä¹ˆæ»šåŠ¨æ•°ç»„ä¼˜åŒ–ï¼Ÿä»ä¸Šé¢å¯ä»¥å‘ç°å‚ä¸çŠ¶æ€è½¬ç§»çš„å˜é‡åªæœ‰3ä¸ªï¼Œä¸”ç›¸äº’ä¸ä¼šå½±å“ï¼Œè¿™ä¸‰ä¸ªå˜é‡åˆ†åˆ«ä¸ºï¼šdp[i][j], dp[i-1][j], dp[i][j-1]

3-dfsçš„å†™æ³• #å¤æ‚åº¦å¤ªé«˜äº†ï¼Œæ²¡å¿…è¦
class Solution:
    def longestCommonSubsequence(self, t1: str, t2: str) -> int:
        @lru_cache(None)
        def dfs(i, j):
            if not i or not j: return 0
            if t1[i-1] == t2[j-1]: return dfs(i-1, j-1) + 1
            return max(dfs(i-1,j), dfs(i, j-1))
        return dfs(len(t1), len(t2))


leetcode-416 åˆ†å‰²ç­‰å’Œå­é›†
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sum_num = sum(nums)
        #å¦‚æœsumä¸ºå¥‡æ•°åˆ™è‚¯å®šæ— æ³•æ»¡è¶³ã€‚
        if sum_num & 1:
            return False
        target = sum_num // 2 #ä¸€ä¸ª/å‡ºæ¥çš„æ˜¯floatï¼Œä¸¤ä¸ª//å‡ºæ¥çš„æ˜¯int
        n = len(nums)
        dp = [[False] * (target+1) for _ in range(n)] #bugå°èƒ½æ‰‹ï¼šè¿™é‡Œå†™é”™äº†ï¼Œä¸­æ‹¬å·å›´ä½çš„åªæœ‰False

        if nums[0] <= target:
            dp[0][nums[0]] = True

        for i in range(1, n):
            for j in range(target+1):
                #å…ˆæŠ„ä¸‹æ¥ï¼Œå†ä¿®æ”¹
                dp[i][j] = dp[i-1][j]

                if nums[i] == j:
                    dp[i][j] = True
                    continue
                if nums[i] < j:
                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]
        return dp[n-1][target]
"""ä¸»è¦å¡åœ¨äº†æ€è·¯ä¸Šï¼š
        1. æˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯åœ¨dp[i][target]ä¸Šèƒ½å¤Ÿå–é“Trueï¼Œæ— è®ºiä¸ºå¤šå°‘ï¼Œåªè¦æ»¡è¶³åœ¨targetå®¹é‡çš„èƒŒåŒ…é‡Œå–åˆ°Trueå°±è¡Œï¼›
            ä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºTrueæ„å‘³ç€åºåˆ—ä¸­å­˜åœ¨å…ƒç´ ç»„åˆèƒ½å¤Ÿç»„åˆæˆtargetï¼Œè€Œtargetå°±æ˜¯é›†åˆçš„ä¸­æ•°ï¼Œå› æ­¤åªè¦èƒ½å–åˆ°Trueå°±æ„å‘³ç€å¯ä»¥åˆ†å‰²æˆä¸¤ä¸ªç›¸åŒçš„å­åºåˆ—ã€‚
        2. è¯¥é¢˜è§£çš„éå†é¡ºåºå’Œä¹‹å‰çš„ä¹Ÿç•¥æœ‰ä¸åŒï¼Œå…ˆéå†æ•°å­—ï¼Œç„¶åå»çœ‹ä»–ä»¬èƒ½æ”¾åœ¨é‚£ä¸ªåŒ…é‡Œä¸ã€‚
        3. å¾ˆç²¾å¦™çš„ä¸€æ­¥éª¤æ˜¯dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]ï¼›
            å‰è€…æ„å‘³ç€è¿™ä¸ªå…ƒç´ ä¸é€‰çš„è¯ï¼Œå…ƒç´ åˆ—è¡¨èƒ½å¦å½¢æˆè¯¥èƒŒåŒ…targetï¼›åè€…æ„å‘³ç€ï¼Œå¦‚æœé€‰æ‹©è¯¥å…ƒç´ åˆ—è¡¨ï¼Œå‰©ä¸‹çš„çš„å…ƒç´ èƒ½å¦ç»„æˆå‰©ä¸‹çš„targetï¼ˆçŠ¶æ€è½¬ç§»ï¼‰
        4. æœ€é‡è¦çš„æ€æƒ³ï¼Œå¦‚ä½•å°†è¿™ä¸ªé—®é¢˜æ„æˆ01èƒŒåŒ…é—®é¢˜ã€‚ä¸€ä¸ªä¸€ä¸ªå…ƒç´ å»çœ‹ï¼Œå®¹é‡ä¹Ÿä¸€ä¸ªä¸ªå¢åŠ ï¼›
"""
2- ä¼˜åŒ–çš„æ–¹æ³•ã€ŒçŠ¶æ€æ•°ç»„ä»äºŒç»´é™ä½è‡³ä¸€ç»´ã€
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sum = 0
        for num in nums:
            sum += num
        if sum & 1:
            return False
        target = sum // 2
        n = len(nums)

        dp = [False for _ in range(target + 1)]

        # ä¾æ®çŠ¶æ€å®šä¹‰åšåˆ¤æ–­:
        # å› ä¸ºä¸‹æ ‡[0,0]ä¸­nums[0]å‡‘ä¸å‡º0æ‰€ä»¥è®¾ç½®æˆFalse
        # å¦‚æœä¾æ®çŠ¶æ€è½¬ç§»åˆ™å¯ä»¥ç†è§£ä¸º:
        # [j - nums[i]] == 0 è¡¨ç¤ºnums[i]æ°å¥½ä¸ºä¸€ç»„,å…¶ä½™ä¸ºä¸€ç»„,åˆšæ‰å‡‘æˆ,æ‰€ä»¥Trueæ²¡é—®é¢˜
        dp[0] = True

        # å…ˆå¡«è¡¨æ ¼ç¬¬ 0 è¡Œï¼Œç¬¬ 1 ä¸ªæ•°åªèƒ½è®©å®¹ç§¯ä¸ºå®ƒè‡ªå·±çš„èƒŒåŒ…æ°å¥½è£…æ»¡
        if nums[0] <= target:
            dp[nums[0]] = True
        
        for i in range(1, n):
            for j in range(target, -1, -1):
                #ã€Œä»åå‘å‰ã€ å†™çš„è¿‡ç¨‹ä¸­ï¼Œä¸€æ—¦ nums[i] <= j ä¸æ»¡è¶³ï¼Œå¯ä»¥é©¬ä¸Šé€€å‡ºå½“å‰å¾ªç¯
                # å› ä¸ºåé¢çš„ j çš„å€¼è‚¯å®šè¶Šæ¥è¶Šå°ï¼Œæ²¡æœ‰å¿…è¦ç»§ç»­åšåˆ¤æ–­ï¼Œç›´æ¥è¿›å…¥å¤–å±‚å¾ªç¯çš„ä¸‹ä¸€å±‚ã€‚
                # ç›¸å½“äºä¹Ÿæ˜¯ä¸€ä¸ªå‰ªæï¼Œè¿™ä¸€ç‚¹æ˜¯ã€Œä»å‰å‘åã€å¡«è¡¨æ‰€ä¸å…·å¤‡çš„ã€‚
                if nums[i] <= j:
                    dp[j] = dp[j] or dp[j - nums[i]]
                else:
                    break

        return dp[-1]
"""
1. è¿™é‡Œå¯èƒ½ä¼šæœ‰äººå›°æƒ‘ä¸ºä»€ä¹ˆå‹ç¼©åˆ°ä¸€ç»´æ—¶ï¼Œè¦é‡‡ç”¨é€†åºã€‚
    å› ä¸ºåœ¨ä¸€ç»´æƒ…å†µä¸‹ï¼Œæ˜¯æ ¹æ® dp[j] || dp[j - nums[i]]æ¥æ¨d[j]çš„å€¼ï¼Œ
    å¦‚ä¸é€†åºï¼Œå°±æ— æ³•ä¿è¯åœ¨å¤–å¾ªç¯ i å€¼ä¿æŒä¸å˜ j å€¼é€’å¢çš„æƒ…å†µä¸‹ï¼Œdp[j - num[i]]çš„å€¼ä¸ä¼šè¢«å½“å‰æ‰€æ”¾å…¥çš„nums[i]æ‰€ä¿®æ”¹ï¼Œ
    å½“jå€¼æœªåˆ°è¾¾ä¸´ç•Œæ¡ä»¶å‰ï¼Œä¼šä¸€ç›´è¢«nums[i]å½±å“ï¼Œä¹Ÿå³æ˜¯å¯èƒ½é‡å¤çš„æ”¾å…¥äº†å¤šæ¬¡nums[i]ï¼Œä¸ºäº†é¿å…å‰é¢å¯¹åé¢äº§ç”Ÿå½±å“ï¼Œæ•…ç”¨é€†åºã€‚ 
    ä¸¾ä¸ªä¾‹å­ï¼Œæ•°ç»„ä¸º[2,2,3,5]ï¼Œè¦æ‰¾å’Œä¸º6çš„ç»„åˆï¼Œi = 0æ—¶ï¼Œdp[2]ä¸ºçœŸï¼Œå½“iè‡ªå¢åˆ°1ï¼Œj = 4æ—¶ï¼Œnums[i] = 2,dp[4] = dp[4] || dp[4 - 2]ä¸ºtrueï¼Œ
    å½“iä¸å˜ï¼Œj = 6æ—¶,dp[6] = dp [6] || dp [6 - 2],è€Œdp[4]ä¸ºtrueï¼Œæ‰€ä»¥dp[6] = true,æ˜¾ç„¶æ˜¯é”™è¯¯çš„ã€‚ æ•…å¿…é¡»å¾—çº æ­£åœ¨æ­£åºæƒ…å†µä¸‹ï¼Œiå€¼ä¸å˜æ—¶å¤šæ¬¡æ”¾å…¥nums[i]çš„æƒ…å†µã€‚
2. å¦‚æœæ˜¯æ­£åºçš„è¯ï¼Œåé¢dpè®¿é—®å‰é¢çš„dpæ—¶å¾—åˆ°çš„æ˜¯å·²ç»æ›´æ–°çš„å†…å®¹ï¼Œæ­¤æ—¶æ±‚çš„æ˜¯å®Œå…¨èƒŒåŒ…é—®é¢˜ã€‚
3. è‡ªå·±çš„ç†è§£ï¼šä¸€ç»´æ—¶é‡‡ç”¨å€’åºï¼Œé‚£ä¹ˆæˆ‘ä»¬éå†çš„jå…ƒç´ åœ¨åˆ©ç”¨[j-nums[i]]æ—¶ï¼Œjå…ƒç´ ä¹‹å‰çš„æ•°æ®éƒ½æ˜¯i-1è¡Œçš„ï¼Œæ˜¯ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„æ•°æ®ï¼Œè€Œæ²¡æœ‰æ”¶åˆ°è¯¥jå…ƒç´ çš„å½±å“ï¼Œå› æ­¤æ˜¯æˆ‘ä»¬éœ€è¦çš„value
"""
3- dfs è®°å¿†åŒ–é€’å½’
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        self.res = False
        s = sum(nums)
        if  s & 1:
            return False
        memo = {}
        target =    s // 2
        def dfs(i, cur):
            if (cur, i) in memo:        #å¦‚æœcur,i åœ¨ä¹‹å‰çš„åˆ†æ”¯ä¸­å·²ç»éå†è¿‡äº†ï¼Œé‚£ä¹ˆè¿™é‡Œå°±å¯ä»¥åšå…¼æå¤„ç†ã€‚
                return memo[(cur, i)]       
            if cur == target:       #ç¡®å®å­˜åœ¨ä¸€ä¸ªé›†åˆçš„å’Œä¸ºtarget
                return True 
            if cur > target or i == len(nums): #curé›†åˆè¶…è¿‡äº†target/æ¢ç´¢åˆ°å¤´äº†ä»æ²¡æ»¡è¶³ï¼Œreturn False
                return False
            res = dfs(i + 1, cur + nums[i]) or dfs(i + 1, cur)  #åªè¦æ»¡è¶³å°±è¿”å›True, å¹¶ä¸”dfsåˆ†æ”¯æ˜¯ä¸¤æ¡
            memo[(cur, i)] = res
            return res 
        return dfs(0, 0)


leetcode-494 ç›®æ ‡å’Œ
1-dfs
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        def dfs(nums, target, index, cur):
            #ç»ˆæ­¢æ¡ä»¶
            if index == len(nums):
                return 1 if cur == target else 0
            
            left  = dfs(nums, target, index+1, cur + nums[index])
            right = dfs(nums, target, index+1, cur - nums[index])
            return left + right 
        return dfs(nums, target, 0, 0)
#è¶…æ—¶ï¼›å¤æ‚åº¦2^n

2-è®°å¿†åŒ–æœç´ 
#ä¼˜åŒ–æ–¹æ³•ï¼šè®°å½•å½“å‰è§£curä¸èŠ‚ç‚¹iï¼Œå¹¶ä¸”åœ¨ä¹‹åçš„å¾ªç¯ä¸­é‡åˆ°çš„è¯ï¼Œåšå‰ªæå¤„ç†ã€‚å› ä¸ºæ— è®ºièŠ‚ç‚¹ä¹‹å‰æ˜¯ä»€ä¹ˆæ’åˆ—ç»„åˆï¼Œä¹‹åçš„æ‰€æœ‰å¯èƒ½éƒ½æ˜¯ä¸€æ ·çš„ï¼Œå› æ­¤å¯ä»¥åšå‰ªæå¤„ç†ã€‚
"""ä¼˜åŒ–ä»£ç 
memo = ()
if (cur, i) in memo:
    continue
....
memo.append((cur, i))
"""
3-åŠ¨æ€è§„åˆ’
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        size  = len(nums)
        s = sum(nums)
        #å¦‚æœæƒ³è¦çš„ç»“æœå¤§äºå’Œï¼Œé‚£ä¹ˆæ— è®ºå¦‚ä½•éƒ½æ˜¯å–ä¸åˆ°çš„ã€‚
        if target > s: return 0 
        dp = [[0] * (2 * s + 1) for _ in range(size + 1)] #å› ä¸ºå…ƒç´ å¯ä»¥æ˜¯ç›¸å‡ï¼Œä¹Ÿå¯ä»¥æ˜¯ç›¸åŠ ï¼Œå› æ­¤æˆ‘ä»¬å¹¶ä¸æ¸…æ¥šç©¶ç«Ÿæ˜¯ä»€ä¹ˆæƒ…å†µ
        dp[0][0 + s] = 1
        
        for i in range(1, size + 1):
            x = nums[i - 1]
            for j in range(-s, s + 1):
                #åŠ ä¸Šx
                if (j - x) + s >= 0:    #çœ‹åŠ ä¸Šçš„æ“ä½œæ˜¯å¦æ»¡è¶³éœ€æ±‚ï¼Œå°±æ˜¯é™åˆ¶æ“ä½œå‰çš„èƒŒåŒ…å®¹é‡åœ¨è¿™ä¸ªèŒƒå›´å†…ï¼Œä¸‹é¢çš„ifåŒç†
                    dp[i][j + s] += dp[i - 1][(j - x) + s]
                #å‡å»x
                if (j + x) + s <= 2 * s:    
                    dp[i][j + s] += dp[i - 1][(j + x) + s]
                #ä¸¤ä¸ªifï¼Œä»£è¡¨äº†ä¸¤ä¸ªè·¯å¾„ã€‚ä¹Ÿå°±æ˜¯è¯´è¯¥èŠ‚ç‚¹å¦‚æœä¸¤ä¸ªéƒ½æ»¡è¶³ï¼Œé‚£ä¹ˆå°±æ˜¯ä¸¤æ¡è·¯ï¼›å¦‚æœåªæ»¡è¶³ä¸€æ¡å­æ¡ä»¶ï¼Œé‚£ä¹ˆå°±æ˜¯ä¸€æ¡è·¯ï¼›å¦‚æœæ²¡æœ‰è·¯å¯ä»¥èµ°ï¼Œé‚£ä¹ˆè‡ªåŠ¨å¿½ç•¥ï¼Œè¿›è¡Œä¸‹ä¸€ä¸ªéå†ã€‚
        return dp[size][target + s]

#å¤æ‚åº¦è¿˜æŒºå¤Ÿé«˜çš„...
#ğŸŒŸè¿™æ¬¡èƒŒåŒ…ä¸ä¸€æ ·çš„åœ°æ–¹åœ¨å…¶å·¦è¾¹ç•Œå¹¶ä¸æ˜¯0ï¼Œè€Œæ˜¯  sï¼Œå› æ­¤è¡¨æ ¼æ˜¯2n+1ï¼Œè€Œénã€‚
#ä¼˜åŒ–æ–¹å‘ï¼šå°†æ— æ³•è§¦è¾¾åˆ°çš„åŒºåŸŸé¿å…æ‰ï¼Œå…·ä½“æ“ä½œæ­¥éª¤æ²¡æœ‰å­¦ã€‚

leetcode-474 ä¸€å’Œé›¶
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[0] * (n + 1) for _ in range(m + 1)]	# é»˜è®¤åˆå§‹åŒ–0
        # éå†ç‰©å“
        for str in strs:
            ones = str.count('1')
            zeros = str.count('0')
            # éå†èƒŒåŒ…å®¹é‡ä¸”ä»åå‘å‰éå†ï¼
            for i in range(m, zeros - 1, -1):       #è¿™é‡Œåˆ©ç”¨äº†zeros - 1å·§å¦™åœ°é¿å¼€äº†è¾¹ç•Œé—®é¢˜ï¼ŒåŒæ—¶å®ç°äº†å‰ªæçš„æ“ä½œã€‚ğŸŒŸ
                for j in range(n, ones - 1, -1):
                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)
        return dp[m][n]
#è¿™é¢˜æŒ‰ç†è¯´ä¸éš¾ï¼ŒçŠ¶æ€è½¬ç§»å°±æ˜¯æ˜¯å¦é€‰æ‹©è¿™ä¸ªå…ƒç´ ï¼Œå¦‚æœé€‰æ‹©å°±å‡å»iå’Œjï¼Œç„¶ååŠ ä¸€ï¼›å¦‚æœä¸é€‰æ‹©ï¼Œé‚£ä¹ˆç›´æ¥ç»§æ‰¿ã€‚
#è¿™é‡Œæ¶‰åŠåˆ°å€’åºæœç´¢ã€‚å› ä¸ºæ¯ä¸€è¡Œæ–°çš„æ•°æ®éœ€è¦åŸºäºä¸Šä¸€ç‰ˆæœ¬/ä¸Šä¸€è¡Œæ•°æ®ï¼Œå› æ­¤éœ€è¦ç‰¹åˆ«æ³¨æ„ä¸€ä¸‹ï¼Œè¿™é‡Œéœ€è¦å€’åºæœç´¢ã€‚




@çœ‹ç­”æ¡ˆè‡ªå·±å†™çš„è·‘ä¸å‡ºæ¥
#åˆ›æ–°ç‚¹åœ¨äºè¿™é‡Œå¼•è¿›äº†dp[i][j][k]ä¸‰ç»´æ•°ç»„ï¼Œä¸å®¹æ˜“ç†è§£ã€‚
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        size = len(strs)
        dp = [[[0] * (n + 1) for _ in range(m + 1)] for _ in range(size + 1)]
        for i in range(1, size + 1):
            ones  = strs[i - 1].count('1')
            zeros = strs[i - 1].count('0')
            for j in range(m + 1):
                for k in range(n + 1):
                    dp[i][j][k] = dp[i - 1][j][k]

                    if j >= ones and k >= zeros:
                        dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1)

        return dp[size][m][n]

leetcode-322 é›¶é’±å…‘æ¢
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        #dp[i] è¡¨ç¤ºæ¢åˆ°é¢å€¼iæ‰€éœ€è¦çš„æœ€å°æ•°é‡
        dp = [float('inf')]*(amount+1)
        dp[0] = 0 #dp[i]:æ¢åˆ°é¢å€¼iæ‰€ç”¨çš„æœ€å°æ•°é‡

        for i in range(len(coins)):
            for j in range(coins[i], amount+1): #æœ€å°é¢å€¼ä»coins[i]å¼€å§‹è®¡ç®—
                dp[j] = min(dp[j], dp[j-coins[i]]+1)
        
        if dp[amount]!=float('inf'):
            return dp[amount]
        else:
            return -1

#æœ¬é¢˜çš„Take-away: 1. å¦‚æœä¸èƒ½æ‹¼æˆåº”æ€ä¹ˆåŠï¼Ÿ 2. ç¡¬å¸æœ‰ä»·å€¼å¤§å°ï¼Ÿæ¯æ¬¡jéå†çš„æ—¶å€™éå†çš„è¾¹ç•Œé—®é¢˜ã€‚ 3.æœ€ååº”è¯¥æ€ä¹ˆåˆ¤æ–­ï¼Ÿ
#1. æœ€åçš„dp[amount] æ²¡æ‹¼æˆçš„è¯å°±ç®—äº†ã€‚
#2. jæ¯æ¬¡éƒ½è¦ä»coins[i]å¼€å§‹ï¼Œå¦‚æœèƒ½æ‹¼æˆå°±è¿›è¡ŒçŠ¶æ€è½¬ç§»ï¼Œæœ€åçš„è½¬ç§»è·¯çº¿åº”è¯¥æ˜¯ä»0åˆ°amountçš„ä¸€æ¡è·¯å¾„ã€‚
#3. è¿™æ ·ä¸‹æ¥æœ€åamountå°±å¯ä»¥åˆ¤æ–­äº†ã€‚

leetcdoe-518 é›¶é’±å…‘æ¢II
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        #å»ºé€ çŸ©é˜µ
        size = len(coins)
        dp = [[0] * (amount + 1) for _ in range(size + 1)]
        
        #dpåˆå§‹åŒ–
        dp[0][0] = 1

        for i in range(1, size + 1):
            for j in range(amount + 1):
                dp[i][j] = dp[i - 1][j]
                k = 1
     
                while (j - k * coins[i - 1]) >= 0:
                    dp[i][j] += dp[i - 1][j - k * coins[i - 1]]
                    k += 1
    
        return dp[size][amount]
#è¿™é‡Œå¾€å‰åšä¸ªå¤ç›˜ï¼Œå…·ä½“çš„ç¬”è®°è®°åœ¨äº†ä¸Šé¢çš„èƒŒåŒ…é—®é¢˜æ±‡æ€»

leetcode-139 å•è¯æ‹†åˆ†
#åˆæ˜¯ä¸€é“æ¨¡ç‰ˆé¢˜ï¼Œdpçš„å†™æ³•è‡ªå·±æƒ³å‡ºæ¥çš„ï¼›
"""
1. DFS
2. è®°å¿†åŒ–æœç´¢
3. BFS
4. ä¼˜åŒ–BFS
5. åŠ¨æ€è§„åˆ’
6. ä¼˜åŒ–åŠ¨æ€è§„åˆ’
"""
1- DFS
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        
        memo = [None]*len(s)                #è®°å¿†åŒ–æœç´¢å¦‚ä½•ç†è§£ï¼Ÿæ¯”å¦‚ç¬¬ä¸€ä¸ªå­æ ‘éå†è¿‡jå…ƒç´ ï¼Œjå…ƒç´ çš„åˆ†æ”¯å¯èƒ½ä¸ºTrue/Falseï¼Œåœ¨ä¹‹åçš„å…¶ä»–å¤§ç±»å­æ ‘ä¸‹å†éå†åˆ°jèŠ‚ç‚¹å¯ä»¥ç›´æ¥è·³è¿‡ï¼Œè¿”å›jèŠ‚ç‚¹çš„å€¼å°±è¡Œã€‚

        # ä»¥ç´¢å¼•iä¸ºèµ·å§‹åˆ°æœ«å°¾çš„å­—ç¬¦ä¸²èƒ½å¦ç”±å­—å…¸ç»„æˆ
        def dfs(i):
            # é•¿åº¦è¶…è¿‡s,è¿”å›True(ç©ºå­—ç¬¦èƒ½ç»„æˆ)
            if i >= len(s): 
                return True
            # å­˜åœ¨ä»¥iä¸ºèµ·å§‹çš„é€’å½’ç»“æœ
            if memo[i] != None:             #è¿™é‡Œå°±æ˜¯å¦‚æœè¯¥èŠ‚ç‚¹è®°å½•è¿‡çš„è¯ï¼Œç›´æ¥ä½¿ç”¨è¯¥èŠ‚ç‚¹çš„å€¼å°±å¥½äº†ï¼Œä¸ç”¨å†å¾€ä¸‹éå†äº†ã€‚
                return memo[i]
            # é€’å½’
            for j in range(i,len(s)):
                if s[i:j+1] in wordDict and dfs(j+1): #å…¶ä¸­[i:j+1]å°±æ˜¯æˆ‘ä»¬å½“å‰éå†çš„å­—ç¬¦ä¸²ï¼Œå¦‚æœæ»¡è¶³è¦æ±‚ï¼Œå¹¶ä¸”å‰©ä¸‹çš„j+1å­æ ‘ä¹Ÿæ»¡è¶³è¦æ±‚ï¼Œé‚£ä¹ˆå°±å¯ä»¥è¿›æ¥ã€‚
                    memo[i] = True                    #è¿›æ¥åï¼Œè¯æ˜äº†ièŠ‚ç‚¹æ˜¯å¯ä»¥æˆåŠŸçš„ã€‚å¹¶ä¸”è¿”å›True
                    return True                       #è¿™ä¸ªè¿”å›å¯ä»¥æ˜¯æ ¹èŠ‚ç‚¹çš„Trueï¼Œä¹Ÿå¯ä»¥æ˜¯å„ä¸ªå­èŠ‚ç‚¹åˆ¤æ–­çš„è¿”å›ã€‚
            memo[i] = False                           #å½“éå†å®Œä¸€ä¸ªå­æ ‘åï¼Œæ²¡æœ‰æˆåŠŸè¿”å›Trueçš„è¯ï¼Œæ‰ä¼šå›æº¯åˆ°è¿™é‡Œã€‚æŠŠè¿™ä¸ªå­æ ‘ä¸‹çš„å„å­æ ‘åˆ¤æ–­çš„memoå›æº¯æ‰ã€‚
            return False
        
        return dfs(0)

2- BFS  #è¿™é“é¢˜è¿˜æŒºå®¹æ˜“ç†è§£çš„ã€‚
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        
        visited = [False]*len(s)
        q = collections.deque()         #åŒå‘é˜Ÿåˆ—
        q.append(0)

        while q:
            i = q.popleft()
            # èŠ‚ç‚¹è‹¥è®¿é—®åˆ™è·³è¿‡
            if visited[i]: 
                continue
            else:
                visited[i] = True
            # æ‰«æä»ç´¢å¼•iå¼€å§‹çš„å­—ç¬¦ä¸²
            for j in range(i,len(s)):
                # å­å­—ç¬¦ä¸²åœ¨å­—å…¸ä¸­
                if s[i:j+1] in wordDict:
                    # å¹¶ä¸”åˆ°è¾¾ç»“å°¾ï¼Œè¿”å›True
                    if j == len(s) - 1:
                        return True
                    # æœªåˆ°è¾¾ç»“å°¾ï¼Œåˆ™æ·»åŠ j+1èµ·å§‹ç´¢å¼•åˆ°é˜Ÿåˆ—
                    else:
                        q.append(j+1)
        
        return False

3- DP 
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        
        # å‰nä¸ªå­—ç¬¦æ˜¯å¦èƒ½ç”±å­—å…¸ç»„æˆ
        dp = [False]*(len(s)+1)
        
        # åˆå§‹çŠ¶æ€
        dp[0] = True

        for i in range(1,len(s)+1): 
            for j in range(i,-1,-1):        
                # è½¬ç§»å…¬å¼
                if dp[j] == True and s[j:i] in wordDict:
                    dp[i] = True
                    break           #å› ä¸ºä¸ç®¡jåœ¨å“ªï¼Œåªè¦jæ»¡è¶³æ¡ä»¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥è¯´æˆ‘ä»¬çš„iæ»¡è¶³æ¡ä»¶ã€‚666
        
        return dp[-1]
# dp[i]æ˜¯[0ï¼Œi]çš„å­—ç¬¦ä¸²èƒ½å¦æ»¡è¶³é¢˜æ„ï¼Œè¿™ä¸€æ®µå­—ç¬¦ä¸²åˆ‡å‰²ä¸º[0, j]å’Œ[j, i]ã€‚

#å½“ç„¶è¿™ä¸ªä¹Ÿå¯ä»¥å½“ä½œä¸€ä¸ªèƒŒåŒ…å¤„ç†é—®é¢˜ã€‚

leetcode-377 ç»„åˆæ€»å’ŒIV
#æœ¬é¢˜ä¸å®Œå…¨èƒŒåŒ…ä¸åŒçš„åœ°æ–¹åœ¨äºï¼šå…ƒç´ çš„ç»„åˆé¡ºåºä¸åŒç®—æ˜¯ä¸åŒçš„ç­”æ¡ˆã€‚
#ğŸŒŸè¿™ä¸€é¢˜æœ‰å‡ ä¸ªå…¨æ–°çŸ¥è¯†ç‚¹ï¼Œç±»ä¼¼åˆ†ç»„èƒŒåŒ…

class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        '''
        #äºŒç»´dpï¼Œè¶…æ—¶
        dp=[[0]*(target+1) for i in range(target+1)]
        dp[0][0]=1
        res=0
        for i in range(1,target+1):             #è¡¨æ˜é•¿åº¦ä¸ºiçš„èƒŒåŒ…
            for j in range(target+1):           #è¿™é‡Œå®¹é‡ä¸ºjçš„èƒŒåŒ…
                for k in nums:                  #éå†numsä¸­çš„k
                    if j-k>=0:                  #ç¡®ä¿å®¹é‡å¤§äºæ•°å­—ï¼Œå› æ­¤æ‰èƒ½æ”¾ä¸‹å‘€ã€‚
                        dp[i][j]+=dp[i-1][j-k]  #æ”¾å…¥äº†kè¿™ä¸ªæ•°ç»„ï¼Œé‚£ä¹ˆè¿™ä¸€ç»„å°±æ˜¯ä¸Šä¸€ç»„ç›¸å¯¹åº”çš„æ–¹æ¡ˆï¼Œä¸Šä¸€ç»„å¯èƒ½+1ï¼Œå¯èƒ½åŠ +2ï¼Œå› æ­¤ä¸¤æ¬¾éƒ½æ»¡è¶³çš„è¯éƒ½ç”¨+=å›Šæ‹¬è¿›æ¥
            res+=dp[i][target]
        return res
        ####
        '''
        #ä¸€ç»´
        dp=[0]*(target+1)
        dp[0]=1
        for i in range(1,target+1):
            for j in nums:
                if i-j>=0:           #å½“å‰numå°äºèƒŒåŒ…å®¹é‡ï¼Œæ„å‘³ç€å¯ä»¥ç”±ä½çº¬èƒŒåŒ…è¿›åŒ–è€Œæ¥ã€‚
                    dp[i]+=dp[i-j]   #è¿™é‡Œçš„å¾ªç¯ç›¸å½“äºbfsï¼Œæ¯ä¸€æ¬¡içš„å¾ªç¯ï¼Œå°±æŠŠå½“å‰æ‰€æœ‰çš„å¯èƒ½æ€§éå†å®Œäº†ã€‚
        return dp[target]
#å› ä¸ºæ˜¯æœ‰åºæ’åˆ—ï¼ŒçŠ¶æ€è½¬ç§»æ—¶è€ƒè™‘çš„ä¸æ˜¯æ˜¯å¦é€‰æ‹©ï¼Œè€Œæ˜¯é€‰æ‹©å“ªä¸ªæ•°ä½œä¸ºè¯¥listçš„ç»“å°¾ã€‚dp[i][j]æ˜¯ié•¿åº¦çš„å’Œä¸ºjçš„æ–¹æ¡ˆæ•°ï¼Œå› æ­¤dp[1]+dp[2]+dp[3]æ˜¯æœ€ç»ˆçš„ç­”æ¡ˆï¼Œè¿™ä¸ªæ€è·¯å¯ä»¥å­¦ä¹ ã€‚
#è¿™é‡Œæœ€æ–°é¢–çš„åœ°æ–¹åœ¨äºé’ˆå¯¹jçš„å¤„ç†ï¼Œè¿™é‡Œçš„jä¸å†æ˜¯ä¸€ä¸ªindexï¼Œè€Œæ˜¯ä¸€ä¸ªæ•°å­—äº†ï¼Œä½†æ˜¯æˆ‘ä»¬çš„iè¿˜æ˜¯â€œindexâ€æ˜¯èƒŒåŒ…çš„å®¹é‡ã€‚

leetcode-309 æœ€ä½³ä¹°å–è‚¡ç¥¨äº‹ä»¶å«å†·å†»æœŸ
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        size = len(prices)
        if size <= 1: return 0

        #dpæ˜¯æŒ‡ç¬¬iå¤©å¯ä»¥å–å¾—çš„æœ€å¤§åˆ©æ¶¦
        dp = [[0] * 3 for _ in range(size)]
        dp[0][0] = 0                #0è¡¨ç¤ºä¸æŒæœ‰ï¼Œä¸”å½“å¤©ä¸å–
        dp[0][1] = -1 * prices[0]   #1è¡¨ç¤ºå½“å¤©æŒæœ‰ï¼ˆä¸ç®¡ä¹°ä¸ä¹°ï¼‰
        dp[0][2] = 0                #2è¡¨ç¤ºä¸æŒæœ‰ï¼Œå½“å¤©å–äº†

        for i in range(1, size):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2])              #å½“å¤©ä¸æŒæœ‰  = æ˜¨å¤©ä¹Ÿä¸æŒæœ‰/æ˜¨å¤©å–äº†
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])  #å½“å¤©æŒæœ‰   = æ˜¨å¤©æŒæœ‰/æ˜¨å¤©ä¹°äº†
            dp[i][2] = dp[i-1][1] + prices[i]                       #ä»Šå¤©å–äº†   = æ˜¨å¤©æŒæœ‰ä»Šå¤©å–äº†ã€‚
        
        return max(dp[size - 1][0], dp[size - 1][2])                #æœ€ååªæ¯”è¾ƒä¸æŒæœ‰çŠ¶æ€ä¸‹çš„æœ€å€¼ã€‚

#Take-awayï¼š1. é¢˜ç›®ä¸­çš„ä¸€äº›æ•°æ®/èƒŒæ™¯å¯èƒ½æ˜¯è¿·é›¾å¼¹ï¼Œå¯¹çŠ¶æ€è½¬æ¢æ²¡æœ‰å½±å“ï¼Œ é’ˆå¯¹æ¬¡ä¸ç”¨è€ƒè™‘å°±è¡Œï¼Œæ¯”å¦‚è¿™é¢˜çš„å†»ç»“æœŸã€‚
#           2. çŠ¶æ€è½¬ç§»å¯èƒ½åˆä¸Šä¸€ä¸ªå¤šä¸ªçŠ¶æ€è½¬ç§»ï¼Œå…·ä½“è§é¢˜ç›®ä¸­çš„forå¾ªç¯ã€‚

leetcode-714
#è‡ªå·±å†™çš„
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        size = len(prices)
        if size <= 1: return 0

        #dpæ˜¯æŒ‡ç¬¬iå¤©å¯ä»¥å–å¾—çš„æœ€å¤§åˆ©æ¶¦
        dp = [[0] * 2 for _ in range(size)]
        dp[0][0] = 0               
        dp[0][1] = -1 * prices[0]   

        for i in range(1, size):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee)
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]) 
            
        return dp[size - 1][0]
#å¤æ‚åº¦ä¸ºOn
@ç©ºé—´ä¼˜åŒ–
#ç©ºé—´ä¼˜åŒ–ä¸ºå¸¸æ•°
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        size = len(prices)
        if size <= 1: return 0

        #dpæ˜¯æŒ‡ç¬¬iå¤©å¯ä»¥å–å¾—çš„æœ€å¤§åˆ©æ¶¦
        dp =[0] * 2
        dp[0] = 0               
        dp[1] = -1 * prices[0]   

        for i in range(1, size):
            dp[0] = max(dp[0], dp[1] + prices[i] - fee)
            dp[1] = max(dp[1], dp[0] - prices[i]) 
            
        return dp[0]
#å¤æ‚åº¦ä¸ºOn

leetcode-123
class Solution:
    def maxProfit(self, prices):
        n=len(prices)
        if n==[]:
            return 0

        #åˆå§‹åŒ–ï¼Œä½†æ˜¯æœ‰ä¸¤ä¸ªç»„åˆå…¶å®ä¸ä¼šå‚ä¸çŠ¶æ€è½¬ç§»ï¼Œ
        dp=[[0,0,0],[0,0,0]] 
        dp[0][0], dp[0][1], dp[0][2] = 0, float('-inf'), float('-inf')
        dp[1][0], dp[1][1], dp[1][2] = -prices[0], float('-inf'), float('-inf')
       
        for i in range(1,n):
            dp[0][1]=max(dp[1][0]+prices[i],dp[0][1])
            dp[0][2]=max(dp[1][1]+prices[i],dp[0][2])
            dp[1][0]=max(dp[0][0]-prices[i],dp[1][0])
            dp[1][1]=max(dp[0][1]-prices[i],dp[1][1])
        return max(dp[0][1],dp[0][2],dp[0][0])
#ğŸŒŸTake-away,åˆå§‹åŒ–ä¸èƒ½å…¨å†™æˆ0ï¼Œå› ä¸ºå…¨å†™æˆ0çš„è¯ï¼Œä¼šé—æ¼ä¸€äº›æƒ…å†µã€‚å› ä¸ºå¦‚æœä¸‹è¾¹æŸäº›å˜é‡éœ€è¦æš‚æ—¶å°äº0ï¼Œä½†æ˜¯ä¸€maxå°±ä¼šé—æ¼è¿™äº›æƒ…å†µï¼Œæ‰€ä»¥ä¼šå‡ºé”™ï¼
#å› æ­¤ï¼Œåœ¨æˆ‘ä»¬å–ä¸åˆ°çš„è¾¹ç•Œï¼Œæˆ‘ä»¬å¯ä»¥ç”¨float('-inf')

leetcode-188 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIV
#çœ‹ä¸‹é¢çš„é¢˜è§£å§
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if len(prices) == 0:
            return 0
        dp = [[0] * (2*k+1) for _ in range(len(prices))]        # è¿™ä¸ªé¢˜è§£æŠŠä¹°å’Œå–æ‹†åˆ†æˆå¥‡å¶æ•°è€Œä¸”è¿™ä¸ªè¾¹ç•Œæ²¡æœ‰åšé™åˆ¶ä¸å¤ªå¦™ã€‚
        for j in range(1, 2*k, 2):
            dp[0][j] = -prices[0]
        for i in range(1, len(prices)):
            for j in range(0, 2*k-1, 2):
                dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j] - prices[i])
                dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1] + prices[i])
        return dp[-1][2*k]

#ï¼ï¼ï¼çœ‹è¿™ä¸ªé¢˜è§£
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        k = min(k, len(prices) // 2)        #kå’Œlenè‚¯å®šæœ‰ä¸€ä¸ªæ˜¯è¾¹ç•Œ

        buy = [-float("inf")] * (k+1)       #å¦‚æœæ˜¯ä¹°å…¥åŠ¨ä½œçš„è¯ï¼Œæ— æ³•é¿å…å°äº0çš„å­˜åœ¨
        sell = [0] * (k+1)                  #å–å‡ºè‡³å°‘ä¸èƒ½äºé’±
    
        for p in prices:                                    #éå†æ¯ä¸€å¤©çš„è‚¡ä»·
            for i in range(1, k+1):                         #æœ€æœ‰è¶£çš„ç‚¹ï¼šç±»ä¼¼bfsï¼ŒæŠŠæ¯ä¸€å¤©çš„æ‰€æœ‰çŠ¶æ€éƒ½æ›´æ–°
                buy[i] = max(buy[i], sell[i-1] - p)         #ç¬¬iå¤©ä¹°äº†ï¼Œ2ç§å¯èƒ½ï¼š1. ä¹‹å‰ä¹°çš„ï¼Œä»Šå¤©æŒè‚¡ï¼Œåˆ™ä¸ºå‰è€…ï¼› 2.æ˜¨å¤©ä¸æŒè‚¡äº†ï¼Œä»Šå¤©ä¹°çš„ï¼Œåˆ™ä¸ºåè€…
                sell[i] = max(sell[i], buy[i] + p)          #ç¬¬iå¤©å–äº†ï¼Œ2ç§å¯èƒ½ï¼š1. ä¹‹å‰å–äº†ï¼Œä¸æŒè‚¡ï¼Œä¸ºå‰è€…;     2.æ˜¨å¤©ä¹°äº†ï¼Œä»Šå¤©å–äº†ï¼Œä¸ºåè€…ã€‚
                # è¿™é‡Œæ³¨æ„ç¥å¥‡çš„æœºåˆ¶ï¼Œå› ä¸ºsell[i]æ›´æ–°æ—¶ï¼Œåˆ©ç”¨äº†æ›´æ–°åçš„buy[i]çš„æ•°æ®ï¼Œè¿™ä¸ªæ—¶å€™buy[i]çš„æ„æ€ä¸æ˜¯æ˜¨å¤©ä¹°äº†ï¼Œè€Œæ˜¯æ˜¨å¤©æŒè‚¡ï¼ æŠŠbuyå’Œsellç†è§£ä¸ºçŠ¶æ€è€ŒéåŠ¨ä½œå°±æˆã€‚
        return sell[-1]     #ä¸éœ€è¦æ³¨æ„buyçš„å˜åŒ–ã€‚

leetcode-583 ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ
#è¿™é¢˜è‡ªå·±æƒ³çš„æ€è·¯â€”â€”è½¬åŒ–æˆå…¬å…±å­åºåˆ—è¿˜æŒºå¯¹çš„ï¼
#ä½¿ç”¨äºŒç»´æ•°ç»„
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)]
        for i in range(len(word1)+1):   #è¿™é‡Œçš„å®šä¹‰éƒ½éå¸¸æœ‰è¶£ï¼Œå› ä¸ºæœ€å¿«ç»“æœè¦å†™å‡ºæ¥ã€‚æ‰€ä»¥åˆå§‹åŒ–çš„æ—¶å€™æŠŠè¾¹ç•Œçš„æœ€åæƒ…å†µå…ˆå†™å‡ºæ¥ã€‚
            dp[i][0] = i
        for j in range(len(word2)+1):
            dp[0][j] = j
        for i in range(1, len(word1)+1):
            for j in range(1, len(word2)+1):
                if word1[i-1] == word2[j-1]:        #æ³¨æ„å­—ç¬¦ä¸²çš„indexå’Œæˆ‘ä»¬çŸ©é˜µä¸­çš„indexæ˜¯æœ‰åå·®çš„ã€‚
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j-1] + 2, dp[i-1][j] + 1, dp[i][j-1] + 1)
        return dp[-1][-1]
#è¿™é¢˜ä¸­é—´çš„çŠ¶æ€è½¬ç§»æœ‰ç‚¹éš¾ä»¥ç†è§£ã€‚
#   1. dp[i][j]æ˜¯èµ°åˆ°iï¼Œjæ—¶å€™ä½¿ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸åŒåˆ é™¤çš„æœ€å°å…ƒç´ ï¼Œæœ€åç­”æ¡ˆå°±æ˜¯i+jï¼Œå®Œå…¨æ²¡æœ‰ç›¸åŒçš„ã€‚ è®°ä½å¤„ç†åçš„dpçŠ¶æ€ä¸ºå­åºåˆ—æ»¡è¶³é¢˜æ„çŠ¶æ€ä¸‹çš„æœ€å°æ­¥æ•°
#   2. çŠ¶æ€è½¬ç§»ï¼šdp[i][j]è·Ÿä¸‰ä¸ªå˜é‡æœ‰å…³ç³»ã€‚1. iå’Œjéƒ½ä¸é€‰ï¼Œå› æ­¤ç­”æ¡ˆä¸ºXXX+2; 2. åªé€‰iæˆ–åªé€‰jï¼Œé‚£ä¹ˆåªç”¨å¤„ç†ä¸€æ­¥å°±å¯ä»¥äº†ï¼Œå³ +1ã€‚

leetcode-72  ç¼–è¾‘è·ç¦»
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n1 = len(word1)
        n2 = len(word2)                 #æŠŠé•¿åº¦å‘½åå‡ºæ¥åä¼šå¿«å¾ˆå¤šï¼
        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]
        #åˆå§‹åŒ–
        for j in range(1, n2 + 1):
            dp[0][j] = dp[0][j-1] + 1
        for i in range(1, n1 + 1):
            dp[i][0] = dp[i-1][0] + 1
        #å¾ªç¯
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1] ) + 1
        #print(dp)      
        return dp[-1][-1]
#è¿™ä¸€é¢˜åŒ583é¢˜ä¸åŒçš„åœ°ç‚¹åœ¨äºçŠ¶æ€çš„è½¬æ¢ã€‚
#å› ä¸ºæ”¯æŒæ·»åŠ ã€åˆ é™¤ã€æ›¿æ¢ï¼Œæ‰€ä»¥åªè¦æœ‰ä¸ä¸€æ ·çš„ï¼Œæ— è®ºæ˜¯å•ä¸ªä¸ä¸€æ ·ï¼Œè¿˜æ˜¯ä¸¤ä¸ªä¸ä¸€æ ·ï¼Œéƒ½åªç”¨ä¸€æ­¥æ“ä½œå°±å¯ä»¥è§£å†³ã€‚


leetcode-650 åªæœ‰ä¸¤ä¸ªé”®çš„é”®ç›˜
class Solution:
    def minSteps(self, n: int) -> int:
        
        dp = [0] * (n + 1)

        for i in range(2, n+1): #å› ä¸ºå¦‚æœåªæœ‰ä¸€ä¸ªAçš„è¯ï¼Œä¸éœ€è¦è¿›è¡Œæ“ä½œï¼Œæ‰€ä»¥ä»2å¼€å§‹
            dp[i] = i           #åˆå§‹åŒ–å¯ä»¥æ”¾åœ¨è¿™é‡Œï¼Œå°±ä¸ç”¨å¤šå†™ä¸€ä¸ªå¾ªç¯äº†
            nb = int(i ** (0.5)) + 1
            for j in range(2, nb):
                if i % j == 0:
                    dp[i] = dp[j] + dp[int(i/j)] 
        return dp[n]
#è¿™é¢˜çš„æ€è·¯æ¯”è¾ƒå¥‡å¦™ï¼šcopyallçš„å­˜åœ¨è¯æ˜äº†æˆ‘ä»¬çš„å¯ä»¥ä¼˜åŒ–çš„å¯¹è±¡æ˜¯èƒ½å¤Ÿç”¨nç»„ç›¸åŒæ•°å­—ç›¸åŠ å¾—åˆ°çš„ã€‚åƒç´ æ•°å°±ä¸è¡Œï¼Œå› ä¸ºé™¤äº†1å’Œå®ƒè‡ªå·±æ²¡æœ‰å…¶ä»–å› æ•°ã€‚
#çŠ¶æ€è½¬ç§»éå¸¸å¥‡å¦™ï¼æ˜ç™½è½¬ç§»è¿‡ç¨‹ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°dp[i]çš„ä¼˜åŒ–æ–¹å¼å°±æ‰¾åˆ°ä¸€ä¸ªå¯ä»¥ç»„æˆiçš„xï¼Œç„¶åçœ‹æœ‰å¤šå°‘ä¸ªxå¯ä»¥ç»„æˆã€‚
#é‚£ä¸ºä»€ä¹ˆä¸ç›´æ¥ç”¨n/x,è€Œç”¨i/jå‘¢ï¼Ÿ å› ä¸ºi/jå¯èƒ½ç»§ç»­è¢«ä¼˜åŒ–ï¼è¿™ä¸ªæ—¶å€™å¯ä»¥åˆ©ç”¨å·²ç»æ›´æ–°è¿‡çš„i/jï¼›
#åœ¨içš„ä¸€ä¸ªå¾ªç¯é‡Œdp[i]å¯ä»¥å¤šæ¬¡è¢«æ“çºµã€‚jè¶Šå¤§ï¼Œé‚£ä¹ˆæ“ä½œæ¬¡æ•°è¶Šå°‘ï¼æ‰€ä»¥è¿™ä¸ªé¡ºåºæ²¡æœ‰ä»€ä¹ˆå½±å“ã€‚ è‡ªå·±è¯•è¿‡äº†ï¼
#è¿™é¢˜å¦™è›™è›™ï¼æ ‡è®°ä¸€ä¸‹ã€‚ğŸŒŸ