leetcode-455
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        ans = 0
        g.sort()
        s.sort()
        n = len(g)
        m = len(s)
        p0 = n - 1
        p1 = m - 1
        while p0 >= 0 and p1 >= 0:
            if s[p1] < g[p0]:
                p0 -= 1
            elif s[p1] >= g[p0]:
                ans += 1
                p0 -= 1
                p1 -= 1
        return ans
#çœ‹è¿‡ç­”æ¡ˆè‡ªå·±å†™çš„ï¼Œå…ˆæŠŠå¤§å—çš„é¥¼å¹²åˆ†äº«ç»™èƒƒå£å¤§çš„ã€‚
#æ¨¡èŒƒç­”æ¡ˆçš„æ—¶é—´ç¨å¥½
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        n, m = len(g), len(s)
        i = j = count = 0

        while i < n and j < m:
            while j < m and g[i] > s[j]:
                j += 1
            if j < m:
                count += 1
            i += 1
            j += 1
        
        return count
#å®˜è§£æ€è·¯ä¸å¤ªä¸€æ ·ï¼Œä»å°çš„èµ°ï¼Œå°çš„å…ˆå–‚é¥±ï¼Œå–‚é¥±åå†å–‚å¤§çš„ã€‚å› ä¸ºé¢˜ç›®è®¾ç½®ï¼Œæ‰€ä»¥ä¸¤ç§æ€è·¯éƒ½å¯ä»¥ï¼Œå¯èƒ½è‡ªå·±çš„æ€è·¯ä¼šé€ æˆä¸€ä¸¢ä¸¢èµ„æºæµªè´¹ã€‚

leetcode-435
#è‡ªå·±å†™çš„â€”â€”é”™äº†ï¼Œåªé€‚ç”¨äºä»å¤´å¼€å§‹çš„æƒ…å†µï¼Œæ²¡æƒ³åˆ°å¦‚æœç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯[1,100]æ€ä¹ˆåŠï¼Ÿ
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        ans = 0 
        p0, p1 = 0, 1
        n = len(intervals)  #åŒ…å«max_index
        while p1 < n and p0 < n:
            if intervals[p0][1] > intervals[p1][0]:
                p1 += 1
                ans += 1
            else:
                p0 += 1
                p1 += 1
        return ans

1- è´ªå¿ƒ
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        intervals.sort(key=lambda x: x[1]) #æŒ‰ç…§å°¾å…ƒç´ æ’åˆ—
        #è¿™ä¸ªæŒ‰ç…§å°¾å·´æ’åºæ˜¯æ•´ä¸ªè´ªå¿ƒçš„æ ¸å¿ƒã€‚
        n = len(intervals)                 #é•¿åº¦
        right = intervals[0][1]             
        ans = 1

        for i in range(1, n):
            if intervals[i][0] >= right:
                ans += 1    #ansæ˜¯æœ‰å‡ ä¸ªåŒºé—´å¯ä»¥è¿åœ¨ä¸€èµ·
                right = intervals[i][1]
        
        return n - ans

leetcode-452
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0 

        points.sort()
        print(points)
        n = len(points)
        i = 0
        ans = j = 1 

        while True: #è¿™é‡Œå†å†™ä»€ä¹ˆå…¶ä»–æŒ‡é’ˆçš„è¾¹ç•Œæ¡ä»¶å°±æ²¡æœ‰æ„ä¹‰äº†ï¼Œå› ä¸ºä½ çœ‹whileå¾ªç¯å¤–é¢æ˜¯æ²¡æœ‰çš„returnçš„ï¼Œå¦ä¸€æ–¹é¢è¿™ä¹Ÿæ˜¯ä¸ªhintè¯´æ˜ä½ çš„ä»£ç å†™çš„åƒåœ¾ã€‚

            if j == n :
                return ans

            while points[i][1] >= points[j][0] and j < n :
                if j == n - 1:
                    return ans
                else:
                    j += 1
            
            i = j
            j += 1
            ans += 1       
 
#ä¸Šé¢æ˜¯è‡ªå·±å†™çš„ï¼Œä½†æ˜¯è¶…æ—¶...æˆ‘å†™çš„æ€æƒ³æ˜¯ï¼Œå¦‚æœæœ€é å·¦çš„æ°”çƒçš„å³è¾¹ç•Œéƒ½èƒ½å›Šæ‹¬åˆ°å…¶ä»–æ°”çƒå·¦è¾¹ç•Œçš„è¯ï¼Œä¹Ÿå°±æ˜¯è¿™ä¸ªæ°”çƒçš„å³è¾¹ç•Œçš„ç®­èƒ½å¤Ÿå°„ç©¿è¿™äº›æ°”çƒï¼Œåˆ™å¯ä»¥è®¡ç®—å‡ºæ¥ã€‚
#è¿™ä»£ç å†™çš„å¥½åƒåœ¾ï¼Œä¸€ç›´åœ¨æ”¹bug
"""
å‡ ä¸ªç¬”è®°å¯ä»¥åšï¼š
1. å› ä¸ºè¿™é‡Œä¸æ˜¯åŒå‘åŒæŒ‡é’ˆï¼Œå› æ­¤whileè·³å‡ºæ¡ä»¶è€…åˆ©ç”¨å¤§å°ä¸å¤ªå¥½ç”¨ï¼Œæˆ‘å†™çš„è·³å‡ºæ¡ä»¶ç›´æ¥ä¸ºreturn
2. ä¸Šé¢ç®—æ³•è‡´å‘½çš„é—®é¢˜ï¼Œæ²¡æœ‰è€ƒè™‘åˆ°ä¸€ç§æƒ…å†µï¼šå¦‚æœæ‰€æœ‰ç¬¬ä¸€ä¸ªå€¼ä¸º[1ï¼Œ100]ï¼Œå…¶ä»–å€¼éƒ½æ˜¯1ï½10ï¼Œåªæœ‰ä¸€ä¸ªä¸º11ï½20ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™åªèƒ½ç”¨2ä¸ªæŒ‡é’ˆ
3. æ²¡æœ‰æŠŠå®é™…é—®é¢˜æŠ½è±¡å‡ºæ¥å½¢æˆæ¨¡å‹ã€‚
"""
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        
        points.sort(key=lambda balloon: balloon[1])
        pos = points[0][1]
        ans = 1
        for balloon in points:
            if balloon[0] > pos:
                pos = balloon[1]
                ans += 1
        
        return ans
#è´ªå¿ƒæ€æƒ³æœ‰è¶£ï¼šé¦–å…ˆå‘ç°ï¼Œå¦‚æœæƒ³è¦å¼“ç®­å°½é‡å°‘çš„è¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸€å®šæ˜¯è¦ä½¿å¾—å®ƒç©¿è¶Šæ›´å¤šçš„æ°”çƒã€‚åŒæ—¶å› ä¸ºæ°”çƒæ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬åªè¦ä»å°¾éƒ¨åœ¨æœ€å·¦ä¾§çš„å¼€å§‹ç€æ‰‹ï¼ˆä¸‹é¢ä¼šè§£é‡Š
#å¦‚æœæœ‰æ°”çƒçš„é¦–éƒ¨èƒ½å’Œæˆ‘ä»¬æ‰¾åˆ°çš„æ°”çƒçš„æœ€å³ä¾§é‡å ï¼Œé‚£ä¹ˆä¸€ä¸ªå¼“ç®­å¯ä»¥è§£å†³è¿™ä¹ˆå¤šï¼›ï¼ˆè¿™å°±æ˜¯è´ªå¿ƒï¼Œæ¯ä¸€å‘å¼“ç®­ï¼Œæˆ‘ä»¬å°½é‡å¸¦èµ°æ°”çƒ
#æ‰€ä»¥å¾€å³èµ°ï¼Œå¦‚æœæœ‰æ°”çƒxæ²¡æœ‰è¾¾åˆ°ä¸Šé¢é‚£ä¸ªæ°”çƒçš„å³ä¾§ï¼Œä¹Ÿå°±æ˜¯è¯´åŸæ¥çš„é‚£æ ¹å¼“ç®­æ— æ³•ç©¿ç ´æ°”çƒxï¼Œé‚£ä¹ˆå°±ä»¥è¿™ä¸ªæ°”çƒxä¸ºåŸºå‡†ï¼Œæ–°å¢ä¸€æ ¹å¼“ç®­ï¼Œé‡å¤ä¸Šé¢çš„æ“ä½œå³å¯ï¼Œç›´åˆ°æœ€åã€‚
#æˆ‘çš„ç­”æ¡ˆé”™çš„ä¸»è¦åŸå› æ˜¯å› ä¸ºæ€è·¯ä¸å¯¹ï¼

leetcode-406
@æ€»ä½“æ€è·¯æ˜¯å…ˆæ’åºå†æ’å…¥
1-ä»é«˜åˆ°ä½
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key=lambda x: (-x[0], x[1]))
        n = len(people)
        ans = list()
        for person in people:
            ans[person[1]:person[1]] = [person] #è¿™ä¸ªåˆ‡ç‰‡æŠ€æœ¯666ï¼Œå¯ä»¥å°†[person]ä¸­åŠ å…¥åˆ°ansï¼Œå¹¶ä¸”è‡ªåŠ¨æ‰©å¼ é•¿åº¦ã€‚
        return ans

2- ä»ä½åˆ°é«˜
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key=lambda x: (x[0], -x[1]))    #äºŒç»´æ•°ç»„å…ˆæŒ‰ç…§x[0]é¡ºåºï¼Œå†æŒ‰ç…§x[1]çš„å€’åºæ’é›·
        n = len(people)
        ans = [[] for _ in range(n)]
        for person in people:
            spaces = person[1] + 1  #è¿™é‡Œ+1å› ä¸ºè‡ªå·±æœ¬èº«è¿˜å ç€ä¸€ä½æ•°
            for i in range(n):
                if not ans[i]:      #å¦‚æœans[i]æœ‰å€¼ï¼Œé‚£ä¹ˆè¿™ä¸ªåœ°æ–¹ä¸èƒ½è®¡æ•°ï¼Œå› ä¸ºæˆ‘ä»¬å…ˆæ’çš„æ˜¯å°çš„å€¼ï¼Œç›®å‰æœ‰å€¼çš„æ˜¯ä¸åº”è¯¥è¢«çº³å…¥è€ƒè™‘çš„
                    spaces -= 1
                    if spaces == 0:  #å¦‚æœç­‰äº0ï¼Œé‚£ä¹ˆå°±æ˜¯è¿™ä¸ªæ•°çš„ä½ç½®
                        ans[i] = person
                        break
        return ans

leetcode-121
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        res = 0 
        low = float("inf")  #ç”¨æ¥æœ€å¼€å§‹è®¾å®šè¾¹ç•Œç”¨
        for price in prices:
            low = min(low, price)   
            res = max(res, price - low)
        return res
#è¿™ä¸€é¢˜ç¬¬äºŒæ¬¡åšäº†ï¼Œæ²¡åšå‡ºæ¥ï¼ŒåŸå› æ˜¯æ²¡æœ‰ç†è§£æ ¸å¿ƒæ€æƒ³
#lowæ˜¯ä¸ºäº†æ¯æ—¥æœ€å°å€¼ï¼Œresçš„æ˜¯æ‰¾æœ€å°å€¼ä¸å½“å‰priceçš„æœ€å¤§ä»·å·®ã€‚
@æˆ‘è‡ªå·±ä¼šè€ƒè™‘æ‰€æœ‰æƒ…å†µ-è¿™æ ·æƒ³ä¸æ˜ç™½ï¼Œå› ä¸ºç»´åº¦å¤ªå¤šè€Œä¸”ç›¸äº’äº¤å‰ã€‚
#ç­”æ¡ˆçš„æ€è·¯ï¼šåªåœ¨ä¹æœ€å°å€¼ï¼Œå’Œå½“å‰priceä¸æœ€å°å€¼çš„ä»·å·®ï¼Œè¿™ä¸¤ä¸ªè¦ç´ ï¼Œå°±å¯ä»¥åº”å¯¹æ‰€æœ‰æƒ…å†µï¼Œcoolï¼


leetcode-122
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        low = 0
        high = 1 
        n = len(prices)
        ans = 0

        while high < n:
            if prices[high] > prices[low]:
                ans += prices[high] - prices[low]
            high += 1
            low += 1

        return ans 
#æ‰‹æ’•-ç®€å•

leetcode-605
#é˜²å¾¡å¼ç¼–ç¨‹ï¼Œå¦‚ä½•å¤„ç†æ•°åˆ—ä¸¤ç«¯çš„æ•°æ®ï¼Œå¯ä»¥åœ¨é¦–å°¾åŠ ä¸Š0
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed = [0] + flowerbed + [0]  #ä¹Ÿå¯ä»¥ç”¨insert()
        i = 1
        ans = 0
        while i < len(flowerbed) - 1:
            if flowerbed[i] == 0 and flowerbed[i-1] == 0 and flowerbed[i+1] ==0:
                i += 2
                ans += 1
            else:
                i += 1
        return n <= ans
#æ—¶é—´å¯ä»¥æ˜¯å¿«çš„ï¼Œä½†æ˜¯ç”±äºæ·»åŠ äº†ä¸¤ä¸ªå…ƒç´ ï¼Œå› æ­¤ç©ºé—´å¯èƒ½ç‰ºç‰²ä¸€äº›
#è¿˜æœ‰ä¸€ç§è§£æ³•ï¼Œå°±æ˜¯æ•°è¿ç»­çš„0ï¼Œç„¶ååˆ©ç”¨æ•°å­¦å½’çº³æ³•ï¼Œå†³å®šå¯ä»¥ç§å¤šå°‘èŠ±

leetcode-392
#ç”¨åŒæŒ‡é’ˆå¾ˆå®¹æ˜“å°±åšå‡ºæ¥é¥¿äº†
#è¿™é“é¢˜ä¹Ÿå¯ä»¥ç”¨DPçŸ©é˜µå»åšï¼Œ= æœ€çŸ­è·¯å¾„é—®é¢˜
@è¾¹ç•Œé—®é¢˜
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        dp = [[0] * len(s) for _ in range(len(t))] #dpçš„indexåº”è¯¥å’Œiå¥‘åˆï¼Œè¿™é‡Œéœ€è¦åŠ ä¸€
        for i in range(len(s)- 1):
            for j in range(len(t) - 1):
                if s[i] == t[j]:
                    dp[i + 1][j + 1] = dp[i][j] + 1 #æœ€å¼€å§‹å€¼éƒ½ä¸º0ï¼Œå¦‚æœå‘ç°ç›¸åŒå­—æ¯ï¼Œå°±è®¡æ•°
                else: 
                    dp[i][j + 1] = dp[i][j]
        return dp[-1][-1] == len(s)
#è¿™ä¸ªæ€è·¯æ˜¯å¯¹çš„ï¼Œä½†æ˜¯listçš„è¾¹ç•Œæœ‰é—®é¢˜ï¼Œå½“éå†æœ€åä¸€ä¸ªå­—æ¯çš„æ—¶å€™ï¼Œdpå·²ç»æ”¾ä¸ä¸‹äº†ã€‚ä¸‹æ–¹ä¸ºä¼˜åŒ–ç‰ˆæœ¬ï¼Œä¸»è¦æ”¹åŠ¨åœ¨indexä¸Š


@åˆå§‹åŒ–é—®é¢˜
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]  #è¿™é‡Œå¦‚æœé”™äº†ä¼šå¯¼è‡´index assignment error
        for i in range(len(s)): #ä¸å‡ä¸€æ˜¯å› ä¸ºè¦ä¿è¯éå†æ‰€æœ‰
            for j in range(len(t)):
                if s[i] == t[j]:
                    dp[i + 1][j + 1] = dp[i][j] + 1 #å› ä¸ºindexçš„å­˜åœ¨ï¼Œæ‰€ä»¥ä¸Šé¢çŸ©é˜µåŠ 1
                else: 
                    dp[i][j + 1] = dp[i][j]
        return dp[-1][-1] == len(s)
#ç¬‘æ­»æˆ‘äº†ï¼Œæˆ‘ä¸ºä»€ä¹ˆçŠ¯è¿™ä¹ˆå›°éš¾çš„é”™è¯¯
"""
éå†é¡ºåºæ˜¯ä»¥i/sä¸ºåŸºå‡†ï¼Œéå†jç„¶åå°†ä¹‹åçš„å…¨éƒ¨+1ï¼Œæ¯”å¦‚é‡åˆ°äº†å­—æ¯aï¼Œå°±ç®—ä¹‹åtä¸­å†æœ‰å­—æ¯aï¼Œè¿™ä¸ªç®—æ³•ä¹Ÿå¯ä»¥ä¿è¯dpæ•°å­—ä¸€æ ·ï¼Œä»è€Œè¾¾åˆ°è·³è¿‡ä¹‹åç›¸åŒå­—æ¯çš„å½±å“
æ¨¡ç‰ˆç­”æ¡ˆä¸ºä¸‹ï¼Œæˆ‘å†™çš„é€»è¾‘æ˜¯æ²¡æœ‰é€»è¾‘ï¼Œå› ä¸ºæ˜¯æŒ‰ç…§ç­”æ¡ˆæ”¹çš„ï¼ğŸŒŸğŸŒŸğŸŒŸé‡ç‚¹ è¿™æ˜¯è¿™ä¸€é¢˜çš„take-away
æˆ‘è€ƒè™‘çš„æ˜¯å°†ç»“æœå­˜åœ¨ä¸‹ä¸€partä¸­ï¼Œä½†æ˜¯æ²¡æœ‰è€ƒè™‘ä¹‹åçš„æ‰€æœ‰é€»è¾‘ï¼Œæ‰€ä»¥å‡ºé”™ã€‚
"""
@æ¨¡ç‰ˆç­”æ¡ˆ
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]
        for i in range(1, len(s)+1):
            for j in range(1, len(t)+1):
                if s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = dp[i][j-1]
        if dp[-1][-1] == len(s):
            return True
        return False

#TIPï¼šéå†æ•°ç»„æ—¶ï¼Œåˆ¤æ–­å…ƒç´ iä¸å…ƒç´ i+1æ—¶ï¼Œæœ€å¥½ä¸è¦ä¿®æ”¹i+1 è€Œæ˜¯ä¿®æ”¹iï¼Œä»¥å…æ¥ä¸‹é‡Œçš„åˆ¤æ–­

#ç¦æ­¢é¢å‘æ¡ˆä¾‹ç¼–ç¨‹ï¼šåœ¨æ²¡æœ‰å¾ˆå¥½çš„åŠæ³•ä¸€æ¬¡æ€§å¤„ç†é—®é¢˜æ—¶ï¼Œå³æ— æ³•å¤„ç†è¾¹é™…/æ¡ä»¶ç­‰ï¼Œè¦é‡æ–°æ€è€ƒæ€è·¯ï¼Œçœ‹æœ‰æ²¡æœ‰æ›´å¥½çš„å¤„ç†æ–¹æ³•å»è§£å†³é—®é¢˜ï¼Œå¦åˆ™å°±ä¼šå¯¼è‡´â€œé¢å‘æ¡ˆä¾‹ç¼–ç¨‹â€ï¼Œä¹Ÿå°±æ˜¯ä»£ç åˆè‡­åˆé•¿ï¼Œè¿™ä¸ªæ—¶å€™å€’ä¸å¦‚ç›´æ¥çœ‹é¢˜è§£çˆ½å¿«ã€‚

#indexä½¿ç”¨iå’Œi+1æ—¶ä¼šå‡ºç°å°´å°¬çš„æƒ…æ™¯ï¼Œåˆ¤æ–­é€»è¾‘é‡Œæ¯ä¸€æ¬¡å¾ªç¯åˆ¤æ–­åº”è¯¥åªé’ˆå¯¹ä¸€ä¸ªæ–°çš„å…ƒç´ ï¼Œä½†æ˜¯æ­¤æ—¶æ— æ³•è€ƒè™‘åˆ°é˜Ÿé¦–ï¼Œå› ä¸ºåˆšå…¥å¾ªç¯çš„æ—¶å€™ï¼Œæ˜¯è¿›å…¥äº†ä¸¤ä¸ªå…ƒç´ ï¼Œå¦‚æœè¦åˆ é™¤ï¼Œæ— æ³•åˆ¤æ–­æ˜¯åˆ é™¤iè¿˜æ˜¯åˆ é™¤i+1
#è¿™ä¸ªæ—¶å€™éœ€è¦åˆ¤æ–­ï¼Œè¿™ç§å°´å°¬çš„åœºæ™¯è·Ÿnumsçš„sizeæ˜¯å¦æœ‰å…³ï¼Œå¦‚æœ3ä¸ªä»¥å†…æ˜¯è¿™ç§ç‰¹ä¾‹ï¼Œé‚£ä¹ˆé€šè¿‡éå†çš„å¼€å§‹æˆ–è€…ç‰¹æ®Šå€¼å¤„ç†æ‰å°±å¥½ã€‚

#èƒ½ç”¨forå°±ä¸ç”¨whileï¼Œç”¨whileæ˜¯å› ä¸ºå¯¹æŒ‡é’ˆå¯ä»¥è¿›è¡Œå¤„ç†ï¼› å¯ä»¥å¤šç”¨iå’Œi-1ï¼Œå› ä¸ºè¿™æ ·åªç”¨é™åˆ¶èŒƒå›´ï¼Œæ¯”è¾ƒå®¹æ˜“ç†è§£ï¼Œé’ˆå¯¹è¾¹ç•Œå¤„ç†ä¹Ÿæ¯”è¾ƒç®€å•ã€‚


leetcode-665
@éš¾ç‚¹_åœ¨äºæ‰€æœ‰æƒ…å†µæ²¡æœ‰å……åˆ†è€ƒè™‘åˆ°å¹¶ä¸”ä¸æ¸…æ¥šåœ¨å„ä¸ªæƒ…å†µä¸‹å¯¹åº”çš„çš„æ“ä½œæ–¹å¼
class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        p = 1 
        count = 0
        n = len(nums)
        while p < n:
            if nums[p - 1] > nums[p]:
                count += 1
                if p == 1 or nums[p] >= nums[p-2]:
                    nums[p - 1] = nums[p]
                else:
                    nums[p] = nums[p - 1]      
            p += 1
        return count <= 1
#é€’å¢åºåˆ—ä¸‰ç§æƒ…å†µï¼š1.æœ€å¤§å€¼åœ¨é˜Ÿé¦– 2.çªå‡ºå€¼åœ¨ä¸¤å…ƒç´ çš„ç¬¬ä¸€ä½ 3.çªå‡ºå€¼åœ¨ä¸¤å…ƒç´ çš„ç¬¬äºŒä½
#å®è§‚æ¥çœ‹ï¼šé™¤äº†è¾¹ç•Œæƒ…å†µï¼Œåœ¨é˜Ÿåˆ—ä¸­é‡åˆ°å¼‚å¸¸æƒ…å†µä¼šæœ‰ä¸¤ç§æƒ…å½¢ï¼Œä¸¤ç§æƒ…å½¢çš„å¤„ç†æ–¹å¼ä¸åŒã€‚

leetcode-53
@æœ€å¤§å­åºå’Œ
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        temp = nums[0]                      #è¿™ä¸ªæ“ä½œååˆ†é‡è¦ï¼Œå¦‚æœä¸æ˜¯ç›´æ¥æ“ä½œtempï¼Œè€Œæ˜¯ä»¥0å…¥åœºï¼Œé‚£ä¹ˆå¦‚æœæ²¡æœ‰æ»¡è¶³çš„æ¡ä»¶çš„è¯ï¼Œè¿”å›çš„å€¼ä¸º0ï¼Œå°½ç®¡ç­”æ¡ˆä¸ºè´Ÿæ•°
        ans = temp

        for i in range(1,len(nums)):
            temp = max(0, temp) + nums[i]    #temp = å­åºåˆ—æœ€åä¸€ä½ä¸ºnums[i]çš„æœ€å¤§å€¼
            ans = max(ans, temp)             #ans  = 1.ä¿å­˜æœ€å¤§å€¼ 2.æ¯”è¾ƒä¸åŒå­åºåˆ—çš„å’Œ
        return ans
#è¿™ç§ä¹Ÿç®—åˆ†æ²»æ€æƒ³
#ä¸‹é¢æ˜¯å¤§ç¥DPçš„ç®—æ³•ï¼Œç‰›ã€‚
class Solution(object):
    def maxSubArray(self, nums):
        for i in range(1, len(nums)):
            nums[i]= nums[i] + max(nums[i-1], 0) 
        return max(nums)

leetcode-763
#è¿™ä¸€é¢˜é¢˜ç›®ç†è§£èµ·æ¥æœ‰éš¾åº¦ï¼Œè´ªå¿ƒç®—æ³•çš„ä½“ç°æ˜¯ä»å¤´é’ˆå¯¹å•ä¸ªå­—æ¯è¿›è¡Œå¤„ç†ã€‚
class Solution:
    def partitionLabels(self, S: str) -> List[int]:
        dic = {s: index for index, s in enumerate(S)}   #dicå‚¨å­˜å­—æ¯ å’Œ æœ€åä¸€æ¬¡å‡ºç°çš„indexï¼Œå®ç°by forçš„éå†å¾ªç¯ #æ³¨æ„enuerateçš„ç”¨æ³•

        num = 0  #ç›´æ¥è®¡æ•°
        result = []
        j = dic[S[0]]  #ç¬¬ä¸€ä¸ªå­—ç¬¦çš„æœ€åä½ç½® #S[0]æ˜¯åˆ—è¡¨


        for i in range(len(S)):  #é€ä¸ªéå†
            num += 1  #æ‰¾åˆ°ä¸€ä¸ªå°±åŠ 1ä¸ªé•¿åº¦
            if dic[S[i]] > j:  #æ€è·¯ä¸€æ ·ï¼Œå¦‚æœæœ€åä½ç½®æ¯”åˆšæ‰çš„å¤§ï¼Œå°±æ›´æ–°æœ€åä½ç½®
                j = dic[S[i]]
            if i == j:  #æ€è·¯ä¸€æ ·ï¼Œå½¢å¼ä¸åŒï¼Œè¿™é‡Œå°±æ˜¯æ‰¾åˆ°è¿™ä¸€æ®µçš„ç»“æŸäº†ï¼Œå°±è¯´æ˜å½“å‰ä½ç½®çš„indexå’Œè¿™ä¸ªå­—æ¯åœ¨å­—å…¸é‡Œçš„æœ€åä½ç½®åº”è¯¥æ˜¯ç›¸åŒçš„ã€‚ -- ç²¾å½©
                result.append(num)  # åŠ å…¥result
                num = 0 # å½’0  -- ç²¾å½©
        return result 
